{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = require('./cursor/AggregationCursor');\n\nconst Query = require('./query');\n\nconst {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n} = require('./helpers/query/applyGlobalOption');\n\nconst getConstructorName = require('./helpers/getConstructorName');\n\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\n\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\n\nconst stringifyFunctionOperators = require('./helpers/aggregate/stringifyFunctionOperators');\n\nconst utils = require('./utils');\n\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](/docs/api.html#model_Model.aggregate) instead.\n *\n * #### Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec(callback);\n *\n * #### Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n * ```javascript\n *   new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *   // Do this instead to cast to an ObjectId\n *   new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n * ```\n *\n * @see MongoDB https://docs.mongodb.org/manual/applications/aggregation/\n * @see driver https://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Model} [model] the model to use with this aggregate.\n * @api public\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n/**\n * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - [`allowDiskUse`](./api.html#aggregate_Aggregate-allowDiskUse)\n * - `bypassDocumentValidation`\n * - [`collation`](./api.html#aggregate_Aggregate-collation)\n * - `comment`\n * - [`cursor`](./api.html#aggregate_Aggregate-cursor)\n * - [`explain`](./api.html#aggregate_Aggregate-explain)\n * - `fieldsAsRaw`\n * - hint\n * - let\n * - `maxTimeMS`\n * - `raw`\n * - `readConcern`\n * - `readPreference`\n * - [`session`](./api.html#aggregate_Aggregate-session)\n * - `writeConcern`\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\n\nAggregate.prototype.options;\n/**\n * Get/set the model that this aggregation will execute on.\n *\n * #### Example:\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\n *     aggregate.model() === MyModel; // true\n *\n *     // Change the model. There's rarely any reason to do this.\n *     aggregate.model(SomeOtherModel);\n *     aggregate.model() === SomeOtherModel; // true\n *\n * @param {Model} [model] set the model associated with this aggregate.\n * @return {Model}\n * @api public\n */\n\nAggregate.prototype.model = function (model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n\n  this._model = model;\n\n  if (model.schema != null) {\n    if (this.options.readPreference == null && model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n\n    if (this.options.collation == null && model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n\n  return model;\n};\n/**\n * Appends new operators to this aggregate pipeline\n *\n * #### Examples:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {Object} ops operator(s) to append\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.append = function () {\n  const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [...arguments];\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n  return this;\n};\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * #### Examples:\n  *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.addFields = function (arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n\n  return this.append({\n    $addFields: Object.assign({}, arg)\n  });\n};\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](#query_Query-select) is also supported.\n *\n * #### Examples:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection https://docs.mongodb.org/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.project = function (arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function (field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) {\n        return;\n      }\n\n      const include = field[0] === '-' ? 0 : 1;\n\n      if (include === 0) {\n        field = field.substring(1);\n      }\n\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({\n    $project: fields\n  });\n};\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group https://docs.mongodb.org/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match https://docs.mongodb.org/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.skip(10);\n *\n * @see $skip https://docs.mongodb.org/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.limit(10);\n *\n * @see $limit https://docs.mongodb.org/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * #### Note:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * #### Examples:\n *\n *     aggregate.near({\n *       near: [40.724, -73.997],\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       uniqueDocs: true,\n *       num: 5\n *     });\n *\n * @see $geoNear https://docs.mongodb.org/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.near = function (arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n/*!\n * define methods\n */\n\n\n'group match skip limit out'.split(' ').forEach(function ($operator) {\n  Aggregate.prototype[$operator] = function (arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * #### Examples:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n *\n * @see $unwind https://docs.mongodb.org/manual/reference/aggregation/unwind/\n * @param {String|Object} fields the field(s) to unwind, either as field names or as [objects with options](https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function () {\n  const args = [...arguments];\n  const res = [];\n\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({\n        $unwind: arg\n      });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: arg[0] === '$' ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' + 'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * #### Examples:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} newRoot the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.replaceRoot = function (newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.count = function (fieldName) {\n  return this.append({\n    $count: fieldName\n  });\n};\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * #### Examples:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\n\nAggregate.prototype.sortByCount = function (arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({\n      $sortByCount: arg\n    });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: arg[0] === '$' ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' + 'must be string or object');\n  }\n};\n/**\n * Appends new custom $lookup operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}* @api public\n */\n\n\nAggregate.prototype.lookup = function (options) {\n  return this.append({\n    $lookup: options\n  });\n};\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Examples:\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.graphLookup = function (options) {\n  const cloneOptions = {};\n\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ? cloneOptions.startWith : '$' + cloneOptions.startWith;\n    }\n  }\n\n  return this.append({\n    $graphLookup: cloneOptions\n  });\n};\n/**\n * Appends new custom $sample operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\n\nAggregate.prototype.sample = function (size) {\n  return this.append({\n    $sample: {\n      size: size\n    }\n  });\n};\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Examples:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort https://docs.mongodb.org/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\n\nAggregate.prototype.sort = function (arg) {\n  // TODO refactor to reuse the query builder logic\n  const sort = {};\n\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function (field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) {\n        return;\n      }\n\n      const ascend = field[0] === '-' ? -1 : 1;\n\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({\n    $sort: sort\n  });\n};\n/**\n * Appends new $unionWith operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n *\n * @see $unionWith https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith\n * @param {Object} options to $unionWith query as described in the above link\n * @return {Aggregate}* @api public\n */\n\n\nAggregate.prototype.unionWith = function (options) {\n  return this.append({\n    $unionWith: options\n  });\n};\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).read('primaryPreferred');\n *\n * @param {String} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver https://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n */\n\n\nAggregate.prototype.read = function (pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).readConcern('majority');\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\n\nAggregate.prototype.readConcern = function (level) {\n  readConcern.call(this, level);\n  return this;\n};\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).redact({\n *       $cond: {\n *         if: { $eq: [ '$level', 5 ] },\n *         then: '$$PRUNE',\n *         else: '$$DESCEND'\n *       }\n *     });\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\n\nAggregate.prototype.redact = function (expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if (typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr) || typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr)) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({\n    $redact: expression\n  });\n};\n/**\n * Execute the aggregation with explain\n *\n * #### Example:\n *\n *     Model.aggregate(..).explain(callback)\n *\n * @param {String} verbosity\n * @param {Function} callback\n * @return {Promise}\n */\n\n\nAggregate.prototype.explain = function (verbosity, callback) {\n  const model = this._model;\n\n  if (typeof verbosity === 'function') {\n    callback = verbosity;\n    verbosity = null;\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (!this._pipeline.length) {\n      const err = new Error('Aggregate has empty pipeline');\n      return cb(err);\n    }\n\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = {\n          error: error\n        };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n\n      model.collection.aggregate(this._pipeline, this.options, (error, cursor) => {\n        if (error != null) {\n          const _opts = {\n            error: error\n          };\n          return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n            cb(error);\n          });\n        }\n\n        if (verbosity != null) {\n          cursor.explain(verbosity, (error, result) => {\n            const _opts = {\n              error: error\n            };\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\n              if (error) {\n                return cb(error);\n              }\n\n              return cb(null, result);\n            });\n          });\n        } else {\n          cursor.explain((error, result) => {\n            const _opts = {\n              error: error\n            };\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\n              if (error) {\n                return cb(error);\n              }\n\n              return cb(null, result);\n            });\n          });\n        }\n      });\n    });\n  }, model.events);\n};\n/**\n * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)\n *\n * #### Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\n\nAggregate.prototype.allowDiskUse = function (value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n/**\n * Sets the hint option for the aggregation query (ignored for < 3.6.0)\n *\n * #### Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec(callback)\n *\n * @param {Object|String} value a hint object or the index name\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\n\nAggregate.prototype.hint = function (value) {\n  this.options.hint = value;\n  return this;\n};\n/**\n * Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html).\n *\n * #### Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\n\nAggregate.prototype.session = function (session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n\n  return this;\n};\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)\n * @param [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param [options.collation] object see [`Aggregate.prototype.collation()`](./docs/api.html#aggregate_Aggregate-collation)\n * @param [options.session] ClientSession see [`Aggregate.prototype.session()`](./docs/api.html#aggregate_Aggregate-session)\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\n\nAggregate.prototype.option = function (value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n\n  return this;\n};\n/**\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\n * because the aggregation result is too big to fit into memory.\n *\n * #### Example:\n *\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\n *     cursor.eachAsync(function(doc, i) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} options.batchSize set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {AggregationCursor} cursor representing this aggregation\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html\n */\n\n\nAggregate.prototype.cursor = function (options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n/**\n * Adds a collation\n *\n * #### Example:\n *\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate\n */\n\n\nAggregate.prototype.collation = function (collation) {\n  this.options.collation = collation;\n  return this;\n};\n/**\n * Combines multiple aggregation pipelines.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().facet({\n *       books: [{ groupBy: '$author' }],\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *     });\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/\n * @api public\n */\n\n\nAggregate.prototype.facet = function (options) {\n  return this.append({\n    $facet: options\n  });\n};\n/**\n * Helper for [Atlas Text Search](https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/)'s\n * `$search` stage.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().\n *      search({\n *        text: {\n *          query: 'baseball',\n *          path: 'plot'\n *        }\n *      });\n *\n *     // Output: [{ plot: '...', title: '...' }]\n *\n * @param {Object} $search options\n * @return {Aggregate} this\n * @see $search https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/\n * @api public\n */\n\n\nAggregate.prototype.search = function (options) {\n  return this.append({\n    $search: options\n  });\n};\n/**\n * Returns the current pipeline\n *\n * #### Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array}\n * @api public\n */\n\n\nAggregate.prototype.pipeline = function () {\n  return this._pipeline;\n};\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * #### Example:\n *\n *     aggregate.exec(callback);\n *\n *     // Because a promise is returned, the `callback` is optional.\n *     const promise = aggregate.exec();\n *     promise.then(..);\n *\n * @see Promise #promise_Promise\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\n\nAggregate.prototype.exec = function (callback) {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n\n  const model = this._model;\n  const collection = this._model.collection;\n  applyGlobalMaxTimeMS(this.options, model);\n  applyGlobalDiskUse(this.options, model);\n\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  return promiseOrCallback(callback, cb => {\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n    stringifyFunctionOperators(this._pipeline);\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = {\n          error: error\n        };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n\n      if (!this._pipeline.length) {\n        return cb(new Error('Aggregate has empty pipeline'));\n      }\n\n      const options = utils.clone(this.options || {});\n      collection.aggregate(this._pipeline, options, (err, cursor) => {\n        if (err != null) {\n          return cb(err);\n        }\n\n        cursor.toArray((error, result) => {\n          const _opts = {\n            error: error\n          };\n          model.hooks.execPost('aggregate', this, [result], _opts, (error, result) => {\n            if (error) {\n              return cb(error);\n            }\n\n            cb(null, result);\n          });\n        });\n      });\n    });\n  }, model.events);\n};\n/**\n * Provides promise for aggregate.\n *\n * #### Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @see Promise #promise_Promise\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\n\n\nAggregate.prototype.then = function (resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like [`.then()`](#query_Query-then), but only takes a rejection handler.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\n\nAggregate.prototype.catch = function (reject) {\n  return this.exec().then(null, reject);\n};\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example\n *\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function () {\n    return this.cursor({\n      useMongooseAggCursor: true\n    }).transformNull()._transformForAsyncIterator();\n  };\n}\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n  return k.length === 1 && k[0][0] === '$';\n}\n/*!\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n */\n\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;","map":{"version":3,"names":["AggregationCursor","require","Query","applyGlobalMaxTimeMS","applyGlobalDiskUse","getConstructorName","prepareDiscriminatorPipeline","promiseOrCallback","stringifyFunctionOperators","utils","read","prototype","readConcern","validRedactStringValues","Set","Aggregate","pipeline","model","_pipeline","_model","options","arguments","length","Array","isArray","append","apply","schema","readPreference","collation","args","every","isOperator","Error","concat","addFields","arg","$addFields","Object","assign","project","fields","keys","forEach","field","split","include","substring","$project","near","op","$geoNear","$operator","unwind","res","push","$unwind","replaceRoot","newRoot","ret","startsWith","$replaceRoot","count","fieldName","$count","sortByCount","$sortByCount","TypeError","lookup","$lookup","graphLookup","cloneOptions","isObject","mergeClone","startWith","$graphLookup","sample","size","$sample","sort","desc","$meta","indexOf","ascend","$sort","unionWith","$unionWith","pref","tags","call","level","redact","expression","thenExpr","elseExpr","has","$cond","if","then","else","$redact","explain","verbosity","callback","cb","err","hooks","execPre","error","_opts","execPost","collection","aggregate","cursor","result","events","allowDiskUse","value","hint","session","option","key","facet","$facet","search","$search","exec","clone","toArray","resolve","reject","catch","Symbol","asyncIterator","useMongooseAggCursor","transformNull","_transformForAsyncIterator","obj","k","_prepareDiscriminatorPipeline","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/aggregate.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = require('./cursor/AggregationCursor');\nconst Query = require('./query');\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require('./helpers/query/applyGlobalOption');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst stringifyFunctionOperators = require('./helpers/aggregate/stringifyFunctionOperators');\nconst utils = require('./utils');\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\n\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](/docs/api.html#model_Model.aggregate) instead.\n *\n * #### Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec(callback);\n *\n * #### Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n * ```javascript\n *   new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *   // Do this instead to cast to an ObjectId\n *   new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n * ```\n *\n * @see MongoDB https://docs.mongodb.org/manual/applications/aggregation/\n * @see driver https://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Model} [model] the model to use with this aggregate.\n * @api public\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\n * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - [`allowDiskUse`](./api.html#aggregate_Aggregate-allowDiskUse)\n * - `bypassDocumentValidation`\n * - [`collation`](./api.html#aggregate_Aggregate-collation)\n * - `comment`\n * - [`cursor`](./api.html#aggregate_Aggregate-cursor)\n * - [`explain`](./api.html#aggregate_Aggregate-explain)\n * - `fieldsAsRaw`\n * - hint\n * - let\n * - `maxTimeMS`\n * - `raw`\n * - `readConcern`\n * - `readPreference`\n * - [`session`](./api.html#aggregate_Aggregate-session)\n * - `writeConcern`\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\nAggregate.prototype.options;\n\n/**\n * Get/set the model that this aggregation will execute on.\n *\n * #### Example:\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\n *     aggregate.model() === MyModel; // true\n *\n *     // Change the model. There's rarely any reason to do this.\n *     aggregate.model(SomeOtherModel);\n *     aggregate.model() === SomeOtherModel; // true\n *\n * @param {Model} [model] set the model associated with this aggregate.\n * @return {Model}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null &&\n        model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null &&\n        model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n\n  return model;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * #### Examples:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {Object} ops operator(s) to append\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  const args = (arguments.length === 1 && Array.isArray(arguments[0]))\n    ? arguments[0]\n    : [...arguments];\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * #### Examples:\n  *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\nAggregate.prototype.addFields = function(arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({ $addFields: Object.assign({}, arg) });\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](#query_Query-select) is also supported.\n *\n * #### Examples:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection https://docs.mongodb.org/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({ $project: fields });\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group https://docs.mongodb.org/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match https://docs.mongodb.org/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.skip(10);\n *\n * @see $skip https://docs.mongodb.org/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.limit(10);\n *\n * @see $limit https://docs.mongodb.org/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * #### Note:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * #### Examples:\n *\n *     aggregate.near({\n *       near: [40.724, -73.997],\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       uniqueDocs: true,\n *       num: 5\n *     });\n *\n * @see $geoNear https://docs.mongodb.org/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * #### Examples:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n *\n * @see $unwind https://docs.mongodb.org/manual/reference/aggregation/unwind/\n * @param {String|Object} fields the field(s) to unwind, either as field names or as [objects with options](https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  const args = [...arguments];\n\n  const res = [];\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg[0] === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * #### Examples:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} newRoot the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.replaceRoot = function(newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.count = function(fieldName) {\n  return this.append({ $count: fieldName });\n};\n\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * #### Examples:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sortByCount = function(arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({ $sortByCount: arg });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: (arg[0] === '$') ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\n      'must be string or object');\n  }\n};\n\n/**\n * Appends new custom $lookup operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}* @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({ $lookup: options });\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Examples:\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appends new custom $sample operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({ $sample: { size: size } });\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Examples:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort https://docs.mongodb.org/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({ $sort: sort });\n};\n\n/**\n * Appends new $unionWith operator to this aggregate pipeline.\n *\n * #### Examples:\n *\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n *\n * @see $unionWith https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith\n * @param {Object} options to $unionWith query as described in the above link\n * @return {Aggregate}* @api public\n */\n\nAggregate.prototype.unionWith = function(options) {\n  return this.append({ $unionWith: options });\n};\n\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).read('primaryPreferred');\n *\n * @param {String} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver https://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).readConcern('majority');\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.readConcern = function(level) {\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).redact({\n *       $cond: {\n *         if: { $eq: [ '$level', 5 ] },\n *         then: '$$PRUNE',\n *         else: '$$DESCEND'\n *       }\n *     });\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||\n        (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({ $redact: expression });\n};\n\n/**\n * Execute the aggregation with explain\n *\n * #### Example:\n *\n *     Model.aggregate(..).explain(callback)\n *\n * @param {String} verbosity\n * @param {Function} callback\n * @return {Promise}\n */\n\nAggregate.prototype.explain = function(verbosity, callback) {\n  const model = this._model;\n  if (typeof verbosity === 'function') {\n    callback = verbosity;\n    verbosity = null;\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (!this._pipeline.length) {\n      const err = new Error('Aggregate has empty pipeline');\n      return cb(err);\n    }\n\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n\n      model.collection.aggregate(this._pipeline, this.options, (error, cursor) => {\n        if (error != null) {\n          const _opts = { error: error };\n          return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n            cb(error);\n          });\n        }\n        if (verbosity != null) {\n          cursor.explain(verbosity, (error, result) => {\n            const _opts = { error: error };\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\n              if (error) {\n                return cb(error);\n              }\n              return cb(null, result);\n            });\n          });\n        } else {\n          cursor.explain((error, result) => {\n            const _opts = { error: error };\n            return model.hooks.execPost('aggregate', this, [result], _opts, error => {\n              if (error) {\n                return cb(error);\n              }\n              return cb(null, result);\n            });\n          });\n        }\n      });\n    });\n  }, model.events);\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)\n *\n * #### Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the hint option for the aggregation query (ignored for < 3.6.0)\n *\n * #### Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec(callback)\n *\n * @param {Object|String} value a hint object or the index name\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.hint = function(value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\n * Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html).\n *\n * #### Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.session = function(session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)\n * @param [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param [options.collation] object see [`Aggregate.prototype.collation()`](./docs/api.html#aggregate_Aggregate-collation)\n * @param [options.session] ClientSession see [`Aggregate.prototype.session()`](./docs/api.html#aggregate_Aggregate-session)\n * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.option = function(value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\n * because the aggregation result is too big to fit into memory.\n *\n * #### Example:\n *\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\n *     cursor.eachAsync(function(doc, i) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} options.batchSize set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {AggregationCursor} cursor representing this aggregation\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n\n/**\n * Adds a collation\n *\n * #### Example:\n *\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate\n */\n\nAggregate.prototype.collation = function(collation) {\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().facet({\n *       books: [{ groupBy: '$author' }],\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *     });\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({ $facet: options });\n};\n\n/**\n * Helper for [Atlas Text Search](https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/)'s\n * `$search` stage.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().\n *      search({\n *        text: {\n *          query: 'baseball',\n *          path: 'plot'\n *        }\n *      });\n *\n *     // Output: [{ plot: '...', title: '...' }]\n *\n * @param {Object} $search options\n * @return {Aggregate} this\n * @see $search https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/\n * @api public\n */\n\nAggregate.prototype.search = function(options) {\n  return this.append({ $search: options });\n};\n\n/**\n * Returns the current pipeline\n *\n * #### Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array}\n * @api public\n */\n\n\nAggregate.prototype.pipeline = function() {\n  return this._pipeline;\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * #### Example:\n *\n *     aggregate.exec(callback);\n *\n *     // Because a promise is returned, the `callback` is optional.\n *     const promise = aggregate.exec();\n *     promise.then(..);\n *\n * @see Promise #promise_Promise\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = function(callback) {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  const model = this._model;\n  const collection = this._model.collection;\n\n  applyGlobalMaxTimeMS(this.options, model);\n  applyGlobalDiskUse(this.options, model);\n\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  return promiseOrCallback(callback, cb => {\n    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n    stringifyFunctionOperators(this._pipeline);\n\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n      if (!this._pipeline.length) {\n        return cb(new Error('Aggregate has empty pipeline'));\n      }\n\n      const options = utils.clone(this.options || {});\n\n      collection.aggregate(this._pipeline, options, (err, cursor) => {\n        if (err != null) {\n          return cb(err);\n        }\n\n        cursor.toArray((error, result) => {\n          const _opts = { error: error };\n          model.hooks.execPost('aggregate', this, [result], _opts, (error, result) => {\n            if (error) {\n              return cb(error);\n            }\n\n            cb(null, result);\n          });\n        });\n      });\n    });\n  }, model.events);\n};\n\n/**\n * Provides promise for aggregate.\n *\n * #### Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @see Promise #promise_Promise\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like [`.then()`](#query_Query-then), but only takes a rejection handler.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example\n *\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor({ useMongooseAggCursor: true }).\n      transformNull().\n      _transformForAsyncIterator();\n  };\n}\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n\n  return k.length === 1 && k[0][0] === '$';\n}\n\n/*!\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n"],"mappings":"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MACD;;MACDN,MAAM,CAACG,KAAD,CAAN,GAAgBE,OAAhB;IACD,CATD;EAUD,CAXM,MAWA;IACL,MAAM,IAAIb,KAAJ,CAAU,sDAAV,CAAN;EACD;;EAED,OAAO,KAAKR,MAAL,CAAY;IAAEuB,QAAQ,EAAEP;EAAZ,CAAZ,CAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA1B,SAAS,CAACJ,SAAV,CAAoBsC,IAApB,GAA2B,UAASb,GAAT,EAAc;EACvC,MAAMc,EAAE,GAAG,EAAX;EACAA,EAAE,CAACC,QAAH,GAAcf,GAAd;EACA,OAAO,KAAKX,MAAL,CAAYyB,EAAZ,CAAP;AACD,CAJD;AAMA;AACA;AACA;;;AAEA,6BAA6BL,KAA7B,CAAmC,GAAnC,EAAwCF,OAAxC,CAAgD,UAASS,SAAT,EAAoB;EAClErC,SAAS,CAACJ,SAAV,CAAoByC,SAApB,IAAiC,UAAShB,GAAT,EAAc;IAC7C,MAAMc,EAAE,GAAG,EAAX;IACAA,EAAE,CAAC,MAAME,SAAP,CAAF,GAAsBhB,GAAtB;IACA,OAAO,KAAKX,MAAL,CAAYyB,EAAZ,CAAP;EACD,CAJD;AAKD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAnC,SAAS,CAACJ,SAAV,CAAoB0C,MAApB,GAA6B,YA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"},"metadata":{},"sourceType":"script"}