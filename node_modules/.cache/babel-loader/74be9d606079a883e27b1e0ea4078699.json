{"ast":null,"code":"'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\n\nconst get = require('../get');\n\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\n\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath = discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n\n      if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return {\n    type: type,\n    schematype: schematype\n  };\n};","map":{"version":3,"names":["cleanPositionalOperators","require","get","getDiscriminatorByValue","updatedPathsByArrayFilter","module","exports","getEmbeddedDiscriminatorPath","schema","update","filter","path","options","parts","split","schematype","type","arrayFilters","Array","isArray","updatedPathsByFilter","i","length","subpath","slice","join","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","key","discriminatorValuePath","discriminatorFilterPath","replace","discriminatorKey","wrapperPath","$elemMatch","filterKey","Object","keys","schemaKey","arrayFilterKey","find","hasOwnProperty","discriminatorSchema","caster","rest","_getPathType"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,wBAAwB,GAAGC,OAAO,CAAC,oCAAD,CAAxC;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAME,uBAAuB,GAAGF,OAAO,CAAC,0CAAD,CAAvC;;AACA,MAAMG,yBAAyB,GAAGH,OAAO,CAAC,qCAAD,CAAzC;AAEA;AACA;AACA;AACA;;;AAEAI,MAAM,CAACC,OAAP,GAAiB,SAASC,4BAAT,CAAsCC,MAAtC,EAA8CC,MAA9C,EAAsDC,MAAtD,EAA8DC,IAA9D,EAAoEC,OAApE,EAA6E;EAC5F,MAAMC,KAAK,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,CAAd;EACA,IAAIC,UAAU,GAAG,IAAjB;EACA,IAAIC,IAAI,GAAG,kBAAX;EAEAN,MAAM,GAAGA,MAAM,IAAI,EAAnB;EACAD,MAAM,GAAGA,MAAM,IAAI,EAAnB;EACA,MAAMQ,YAAY,GAAGL,OAAO,IAAI,IAAX,IAAmBM,KAAK,CAACC,OAAN,CAAcP,OAAO,CAACK,YAAtB,CAAnB,GACnBL,OAAO,CAACK,YADW,GACI,EADzB;EAEA,MAAMG,oBAAoB,GAAGhB,yBAAyB,CAACK,MAAD,CAAtD;;EAEA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,KAAK,CAACS,MAA1B,EAAkC,EAAED,CAApC,EAAuC;IACrC,MAAME,OAAO,GAAGvB,wBAAwB,CAACa,KAAK,CAACW,KAAN,CAAY,CAAZ,EAAeH,CAAC,GAAG,CAAnB,EAAsBI,IAAtB,CAA2B,GAA3B,CAAD,CAAxC;IACAV,UAAU,GAAGP,MAAM,CAACG,IAAP,CAAYY,OAAZ,CAAb;;IACA,IAAIR,UAAU,IAAI,IAAlB,EAAwB;MACtB;IACD;;IAEDC,IAAI,GAAGR,MAAM,CAACkB,QAAP,CAAgBH,OAAhB,CAAP;;IACA,IAAI,CAACR,UAAU,CAACY,eAAX,IAA8BZ,UAAU,CAACa,+BAA1C,KACAb,UAAU,CAACP,MAAX,CAAkBqB,cAAlB,IAAoC,IADxC,EAC8C;MAC5C,MAAMC,GAAG,GAAG5B,GAAG,CAACa,UAAD,EAAa,iCAAb,CAAf;MACA,MAAMgB,sBAAsB,GAAGR,OAAO,GAAG,GAAV,GAAgBO,GAA/C;MACA,MAAME,uBAAuB,GAC3BD,sBAAsB,CAACE,OAAvB,CAA+B,SAA/B,EAA0C,GAA1C,CADF;MAEA,IAAIC,gBAAgB,GAAG,IAAvB;;MAEA,IAAIH,sBAAsB,IAAIrB,MAA9B,EAAsC;QACpCwB,gBAAgB,GAAGxB,MAAM,CAACqB,sBAAD,CAAzB;MACD;;MACD,IAAIC,uBAAuB,IAAItB,MAA/B,EAAuC;QACrCwB,gBAAgB,GAAGxB,MAAM,CAACsB,uBAAD,CAAzB;MACD;;MAED,MAAMG,WAAW,GAAGZ,OAAO,CAACU,OAAR,CAAgB,QAAhB,EAA0B,EAA1B,CAApB;;MACA,IAAIlB,UAAU,CAACa,+BAAX,IACA1B,GAAG,CAACQ,MAAM,CAACyB,WAAD,CAAP,EAAsB,gBAAgBL,GAAtC,CAAH,IAAiD,IADrD,EAC2D;QACzDI,gBAAgB,GAAGxB,MAAM,CAACyB,WAAD,CAAN,CAAoBC,UAApB,CAA+BN,GAA/B,CAAnB;MACD;;MAED,IAAIC,sBAAsB,IAAItB,MAA9B,EAAsC;QACpCyB,gBAAgB,GAAGzB,MAAM,CAACsB,sBAAD,CAAzB;MACD;;MAED,KAAK,MAAMM,SAAX,IAAwBC,MAAM,CAACC,IAAP,CAAYnB,oBAAZ,CAAxB,EAA2D;QACzD,MAAMoB,SAAS,GAAGpB,oBAAoB,CAACiB,SAAD,CAApB,GAAkC,GAAlC,GAAwCP,GAA1D;QACA,MAAMW,cAAc,GAAGJ,SAAS,GAAG,GAAZ,GAAkBP,GAAzC;;QACA,IAAIU,SAAS,KAAKR,uBAAlB,EAA2C;UACzC,MAAMtB,MAAM,GAAGO,YAAY,CAACyB,IAAb,CAAkBhC,MAAM,IAAIA,MAAM,CAACiC,cAAP,CAAsBF,cAAtB,CAA5B,CAAf;;UACA,IAAI/B,MAAM,IAAI,IAAd,EAAoB;YAClBwB,gBAAgB,GAAGxB,MAAM,CAAC+B,cAAD,CAAzB;UACD;QACF;MACF;;MAED,IAAIP,gBAAgB,IAAI,IAAxB,EAA8B;QAC5B;MACD;;MAED,MAAMU,mBAAmB,GAAGzC,uBAAuB,CAACY,UAAU,CAAC8B,MAAX,CAAkBhB,cAAnB,EAAmCK,gBAAnC,CAAvB,CAA4E1B,MAAxG;MAEA,MAAMsC,IAAI,GAAGjC,KAAK,CAACW,KAAN,CAAYH,CAAC,GAAG,CAAhB,EAAmBI,IAAnB,CAAwB,GAAxB,CAAb;MACAV,UAAU,GAAG6B,mBAAmB,CAACjC,IAApB,CAAyBmC,IAAzB,CAAb;;MACA,IAAI/B,UAAU,IAAI,IAAlB,EAAwB;QACtBC,IAAI,GAAG4B,mBAAmB,CAACG,YAApB,CAAiCD,IAAjC,CAAP;QACA;MACD;IACF;EACF;;EAED,OAAO;IAAE9B,IAAI,EAAEA,IAAR;IAAcD,UAAU,EAAEA;EAA1B,CAAP;AACD,CAvED"},"metadata":{},"sourceType":"script"}