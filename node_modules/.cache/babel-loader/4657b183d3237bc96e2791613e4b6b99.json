{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\n\nconst isPathExcluded = require('../projection/isPathExcluded');\n\nconst lookupLocalFields = require('./lookupLocalFields');\n\nconst mpath = require('mpath');\n\nconst util = require('util');\n\nconst utils = require('../../utils');\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' + util.inspect(queryProjection));\n  } // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath; // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n  let modelNames;\n\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  modelNames = utils.array.flatten(modelNames);\n  return modelNames;\n};","map":{"version":3,"names":["MongooseError","require","isPathExcluded","lookupLocalFields","mpath","util","utils","hasNumericPropRE","module","exports","modelNamesFromRefPath","refPath","doc","populatedPath","modelSchema","queryProjection","inspect","test","chunks","split","length","Error","_refPath","_remaining","i","chunk","startsWith","substring","refValue","get","modelNames","Array","isArray","array","flatten","virtuals","hasOwnProperty","applyGetters"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\nconst isPathExcluded = require('../projection/isPathExcluded');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst util = require('util');\nconst utils = require('../../utils');\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  modelNames = utils.array.flatten(modelNames);\n\n  return modelNames;\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}