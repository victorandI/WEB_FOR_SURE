{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Kareem = require('kareem');\n\nconst MongooseError = require('./error/mongooseError');\n\nconst SchemaType = require('./schematype');\n\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\n\nconst VirtualOptions = require('./options/VirtualOptions');\n\nconst VirtualType = require('./virtualtype');\n\nconst addAutoId = require('./helpers/schema/addAutoId');\n\nconst get = require('./helpers/get');\n\nconst getConstructorName = require('./helpers/getConstructorName');\n\nconst getIndexes = require('./helpers/schema/getIndexes');\n\nconst idGetter = require('./helpers/schema/idGetter');\n\nconst merge = require('./helpers/schema/merge');\n\nconst mpath = require('mpath');\n\nconst readPref = require('./driver').get().ReadPreference;\n\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\n\nconst utils = require('./utils');\n\nconst validateRef = require('./helpers/populate/validateRef');\n\nconst util = require('util');\n\nlet MongooseTypes;\n\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').middlewareFunctions;\n\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\n\nconst hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set());\nconst isPOJO = utils.isPOJO;\nlet id = 0;\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n *\n * #### Options for Nested Schemas:\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.methodOptions = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = []; // For internal debugging. Do not use this to try to save a schema in MDB.\n\n  this.$id = ++id;\n  this.mapPaths = [];\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options); // build paths\n\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  } // check if _id's value is a subdocument (gh-2276)\n\n\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id); // ensure the documents get an auto _id unless disabled\n\n\n  const auto_id = !this.paths['_id'] && this.options._id && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n/*!\n * Create virtual properties with alias field\n */\n\n\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n    schema.virtual(alias).get(function (p) {\n      return function () {\n        if (typeof this.get === 'function') {\n          return this.get(p);\n        }\n\n        return this[p];\n      };\n    }(prop)).set(function (p) {\n      return function (v) {\n        return this.$set(p, v);\n      };\n    }(prop));\n  }\n}\n/*!\n * Inherit from EventEmitter.\n */\n\n\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n/**\n * Schema as a tree\n *\n * #### Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function () {\n  const s = this._clone(); // Bubble up `init` for backwards compat\n\n\n  s.on('init', v => this.emit('init', v));\n  return s;\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function (f) {\n    return f;\n  });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n  return s;\n};\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {Array} paths list of paths to pick\n * @param {Object} [options] options to pass to the schema constructor. Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\n\nSchema.prototype.pick = function (paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' + 'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({\n        [path]: get(this.tree, path)\n      });\n    } else {\n      const schematype = this.path(path);\n\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n\n      newSchema.add({\n        [path]: schematype\n      });\n    }\n  }\n\n  return newSchema;\n};\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\n\nSchema.prototype.defaultOptions = function (options) {\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n  const baseOptions = this.base && this.base.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  options = utils.options({\n    strict: strict,\n    strictQuery: 'strict' in this._userProvidedOptions ? this._userProvidedOptions.strict : 'strictQuery' in baseOptions ? baseOptions.strictQuery : strict,\n    bufferCommands: true,\n    capped: false,\n    // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    _id: true,\n    id: true,\n    typeKey: 'type'\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + typeof options.versionKey + '`');\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * ####Example:\n *\n *     const options = { discriminatorKey: 'kind' };\n *\n *     const eventSchema = new mongoose.Schema({ time: Date }, options);\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     // ClickedLinkEvent is a special type of Event that has\n *     // a URL.\n *     const ClickedLinkEvent = Event.discriminator('ClickedLink',\n *     new mongoose.Schema({ url: String }, options));\n *\n *     // When you create a generic event, it can't have a URL field...\n *     const genericEvent = new Event({ time: Date.now(), url: 'google.com' });\n *     assert.ok(!genericEvent.url);\n *     // But a ClickedLinkEvent can\n *     const clickedEvent = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\n *     assert.ok(clickedEvent.url);\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the Schema of the discriminated Schema\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.discriminator = function (name, schema) {\n  this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, {\n    [name]: schema\n  });\n  return this;\n};\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {\n    merge(this, obj);\n    return this;\n  } // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n\n\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || ''; // avoid prototype pollution\n\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n\n  for (const key of keys) {\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath + '`, got value \"' + val + '\"');\n    } // Retain `_id: false` but don't set it as a path, re: gh-8274.\n\n\n    if (key === '_id' && val === false) {\n      continue;\n    }\n\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath + '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n\n      this.path(prefix + key, val);\n\n      if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {\n        const applyDiscriminators = val[0]._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      } else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {\n        const applyDiscriminators = val._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || typeKey === 'type' && isPOJO(val.type) && val.type.type) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        const _schema = new Schema(_typeDef);\n\n        const schemaWrappedPath = Object.assign({}, val, {\n          type: _schema\n        });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        this.path(prefix + key, val);\n\n        if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const addedKeys = Object.keys(obj).map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n  return this;\n};\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\nconst reserved = Schema.reserved; // Core object\n\nreserved['prototype'] = // EventEmitter\nreserved.emit = reserved.listeners = reserved.on = reserved.removeListener = // document properties and functions\nreserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;\nreserved.collection = 1;\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function (path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n\n    if (schematype != null) {\n      return schematype;\n    } // Look for maps\n\n\n    const mapPath = getMapPath(this, path);\n\n    if (mapPath != null) {\n      return mapPath;\n    } // Look if a parent of this path is mixed\n\n\n    schematype = this.hasMixedParent(cleanPath);\n\n    if (schematype != null) {\n      return schematype;\n    } // subpaths?\n\n\n    return /\\.\\d+\\.?.*$/.test(path) ? getPositionalPath(this, path) : undefined;\n  } // some path names conflict with document methods\n\n\n  const firstPieceOfPath = path.split('.')[0];\n\n  if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` + 'You are allowed to use it, but use at your own risk. ' + 'To disable this warning pass `supressReservedKeysWarning` as a schema option.';\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  } // update the tree\n\n\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. ' + 'Parent path `' + fullPath + '` already set to type ' + branch[sub].name + '.';\n      throw new Error(msg);\n    }\n\n    branch = branch[sub];\n  }\n\n  branch[last] = utils.clone(obj);\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n    }\n\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.subpaths[key];\n    }\n\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n    const toAdd = [];\n\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$'; // Skip arrays of document arrays\n\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.schema,\n        model: schematype.caster\n      });\n    }\n  }\n\n  return childSchemas;\n}\n/*!\n * ignore\n */\n\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n/*!\n * ignore\n */\n\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n/*!\n * ignore\n */\n\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.prototype.interpretAsType = function (path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  } // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n\n\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  } // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n\n\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type) ? obj[options.typeKey] : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = type === Array || type === 'array' ? obj.cast || obj.of : type[0]; // new Schema({ path: [new Schema({ ... })] })\n\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path + '` is from a different copy of the Mongoose module. ' + 'Please make sure you\\'re using the same version ' + 'of Mongoose everywhere with `npm list mongoose`. If you are still ' + 'getting this error, please add `new Schema()` around the path: ' + `${path}: new Schema(...)`);\n      }\n\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n\n    if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path + '` is from a different copy of the Mongoose module. ' + 'Please make sure you\\'re using the same version ' + 'of Mongoose everywhere with `npm list mongoose`. If you are still ' + 'getting this error, please add `new Schema()` around the path: ' + `${path}: new Schema(...)`);\n      }\n\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    } // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n\n\n    const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = {\n          minimize: options.minimize\n        };\n\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        } // propagate 'strict' option to child schema\n\n\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string' ? type : type.schemaName || utils.getFunctionName(type); // For Jest 26+, see #10296\n\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' + `Could not determine the embedded type for array \\`${path}\\`. ` + 'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' + `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` + 'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  } // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n\n\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  } // For Jest 26+, see #10296\n\n\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` + 'invalid. See ' + 'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` + `a valid type at path \\`${path}\\`. See ` + 'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n/*!\n * ignore\n */\n\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = {\n    type: {}\n  };\n\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n\n    if (isInlineSchema) {\n      _mapType = {\n        [schema.options.typeKey]: new Schema(obj.of)\n      };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = {\n        [schema.options.typeKey]: obj.of\n      };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\n\nSchema.prototype.eachPath = function (fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\n\nSchema.prototype.pathType = function (path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  } // Look for maps\n\n\n  const mapPath = getMapPath(this, path);\n\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n\n  return 'adhocOrUndefined';\n};\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\n\nSchema.prototype.hasMixedParent = function (path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n\n    if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\n\n\nSchema.prototype.setupTimestamp = function (timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n/*!\n * ignore. Deprecated re: #6405\n */\n\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ? self.paths[subpaths[0]] : 'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n\n      break;\n    } // ignore if its just a position segment: path.0.subpath\n\n\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = type === 'nested';\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n\n  if (val) {\n    return 'real';\n  }\n\n  if (isNested) {\n    return 'nested';\n  }\n\n  return 'adhocOrUndefined';\n}\n/*!\n * ignore\n */\n\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\n\nSchema.prototype.queue = function (name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n/**\n * Defines a pre hook for the model.\n *\n * #### Example\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\n\nSchema.prototype.pre = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n\n    return this;\n  }\n\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n\n    return this;\n  }\n\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\n\nSchema.prototype.post = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n\n    return this;\n  }\n\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n\n    return this;\n  }\n\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\n\nSchema.prototype.plugin = function (fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' + 'got \"' + typeof fn + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n\n  this.plugins.push({\n    fn: fn,\n    opts: opts\n  });\n  fn(this, opts);\n  return this;\n};\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\n\nSchema.prototype.method = function (name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n\n  return this;\n};\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n * @see Statics /docs/guide.html#statics\n */\n\n\nSchema.prototype.static = function (name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n\n  return this;\n};\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\n\nSchema.prototype.index = function (fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n\n  return this;\n};\n/**\n * Sets a schema option.\n *\n * #### Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\n\nSchema.prototype.set = function (key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n\n      break;\n\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key option name\n * @api public\n * @return {Any} the option's value\n */\n\n\nSchema.prototype.get = function (key) {\n  return this.options[key];\n};\n/**\n * The allowed index types\n *\n * @receiver Schema\n * @static indexTypes\n * @api public\n */\n\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function () {\n    return indexTypes;\n  },\n  set: function () {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function () {\n  return getIndexes(this);\n};\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @return {VirtualType}\n */\n\n\nSchema.prototype.virtual = function (name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function (obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n    const virtual = this.virtual(name);\n    virtual.options = options;\n    virtual.set(function (_v) {\n      if (!this.$$populatedVirtuals) {\n        this.$$populatedVirtuals = {};\n      }\n\n      if (options.justOne || options.count) {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n\n        if (typeof this.$$populatedVirtuals[name] !== 'object') {\n          this.$$populatedVirtuals[name] = options.count ? _v : null;\n        }\n      } else {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function (doc) {\n          return doc && typeof doc === 'object';\n        });\n      }\n    });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    } // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210\n\n\n    const parts = name.split('.');\n    let cur = parts[0];\n\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' + ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});\n    return mem[part];\n  }, this.tree);\n  return virtuals[name];\n};\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\n\nSchema.prototype.virtualpath = function (name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * @param {String|Array} path\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.remove = function (path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach(function (name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));\n\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n\n        _deletePath(this, name);\n\n        return;\n      }\n\n      delete this.paths[name];\n\n      _deletePath(this, name);\n    }, this);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](/docs/guide.html#virtuals),\n * [statics](/docs/guide.html#statics), and\n * [methods](/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\n\n\nSchema.prototype.loadClass = function (model, virtualsOnly) {\n  if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly); // Add static methods\n\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function (name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  } // Add methods and virtuals\n\n\n  Object.getOwnPropertyNames(model.prototype).forEach(function (name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n\n      this.virtual(name).get(method.get);\n    }\n\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n  return this;\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getSchema = function (path) {\n  const _this = this;\n\n  const pathschema = _this.path(path);\n\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          } // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n\n\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                } // comments.$.comments.$.title\n\n\n                ret = search(parts.slice(p + 1), foundschema.schema);\n\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n                }\n\n                return ret;\n              } // this is the last path of the selector\n\n\n              ret = search(parts.slice(p), foundschema.schema);\n\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n              }\n\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          } // Any path in the map will be an instance of the map's embedded schematype\n\n\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n          return ret;\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n        return foundschema;\n      }\n    }\n  } // look for arrays\n\n\n  const parts = path.split('.');\n\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n\n  return search(parts, _this);\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getPathType = function (path) {\n  const _this = this;\n\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return {\n              schema: foundschema,\n              pathType: 'mixed'\n            };\n          } // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n\n\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return {\n                  schema: foundschema,\n                  pathType: 'nested'\n                };\n              } // comments.$.comments.$.title\n\n\n              return search(parts.slice(p + 1), foundschema.schema);\n            } // this is the last path of the selector\n\n\n            return search(parts.slice(p), foundschema.schema);\n          }\n\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n\n        return {\n          schema: foundschema,\n          pathType: 'real'\n        };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return {\n          schema: schema,\n          pathType: 'nested'\n        };\n      }\n    }\n\n    return {\n      schema: foundschema || schema,\n      pathType: 'undefined'\n    };\n  } // look for arrays\n\n\n  return search(path.split('.'), _this);\n};\n/*!\n * ignore\n */\n\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n/*!\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n */\n\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n/*!\n * Module exports.\n */\n\n\nmodule.exports = exports = Schema; // require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](/docs/schematypes.html#strings)\n * - [Number](/docs/schematypes.html#numbers)\n * - [Boolean](/docs/schematypes.html#booleans) | Bool\n * - [Array](/docs/schematypes.html#arrays)\n * - [Buffer](/docs/schematypes.html#buffers)\n * - [Date](/docs/schematypes.html#dates)\n * - [ObjectId](/docs/schematypes.html#objectids) | Oid\n * - [Mixed](/docs/schematypes.html#mixed)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;","map":{"version":3,"names":["EventEmitter","require","Kareem","MongooseError","SchemaType","SchemaTypeOptions","VirtualOptions","VirtualType","addAutoId","get","getConstructorName","getIndexes","idGetter","merge","mpath","readPref","ReadPreference","setupTimestamps","utils","validateRef","util","MongooseTypes","queryHooks","middlewareFunctions","documentHooks","hookNames","concat","reduce","s","hook","add","Set","isPOJO","id","Schema","obj","options","paths","aliases","subpaths","virtuals","singleNestedPaths","nested","inherits","callQueue","_indexes","methods","methodOptions","statics","tree","query","childSchemas","plugins","$id","mapPaths","hooks","defaultOptions","Array","isArray","definition","_idSubDoc","_id","isObject","auto_id","setupTimestamp","timestamps","aliasFields","schema","Object","keys","path","prop","alias","Error","virtual","p","set","v","$set","prototype","create","constructor","instanceOfSchema","defineProperty","configurable","enumerable","writable","clone","_clone","on","emit","Constructor","base","_userProvidedOptions","map","f","slice","call","gatherChildSchemas","$globalPluginsApplied","$isRootDiscriminator","$implicitlyCreated","$originalSchemaId","discriminatorMapping","assign","discriminators","_applyDiscriminators","pick","newSchema","schematype","baseOptions","strict","strictQuery","bufferCommands","capped","versionKey","optimisticConcurrency","minimize","autoIndex","discriminatorKey","shardKey","read","validateBeforeSave","typeKey","discriminator","name","prefix","key","fullPath","val","TypeError","length","substring","schemaType","applyDiscriminators","disc","type","_typeDef","_schema","schemaWrappedPath","addedKeys","removeIndex","index","arguments","i","isDeepStrictEqual","splice","clearIndexes","reserved","listeners","removeListener","collection","errors","init","isModified","isNew","populated","remove","save","toObject","validate","cleanPath","_pathToPositionalSyntax","undefined","_getPath","mapPath","getMapPath","hasMixedParent","test","getPositionalPath","firstPieceOfPath","split","supressReservedKeysWarning","errorMessage","warn","hasUserDefinedProperty","ref","last","pop","branch","sub","msg","interpretAsType","$isSchemaMap","$__schemaType","push","$isSingleNested","value","caster","model","$isMongooseDocumentArray","casterConstructor","$isMongooseArray","arrayPath","_schemaType","toAdd","$embeddedSchemaType","_arrayPath","_arrayParentPath","$isUnderneathDocArray","hasOwnProperty","replace","_path","re","RegExp","Types","constructorName","getFunctionName","oldObj","Function","Mixed","cast","of","DocumentArray","castFromTypeKey","charAt","toUpperCase","childSchemaOptions","childSchema","schemaName","Subdocument","Buffer","isBuffer","toString","createMapNestedSchemaType","_mapType","isInlineSchema","subdocumentSchema","eachPath","subpath","select","fn","len","requiredPaths","invalidate","_requiredpaths","ret","isRequired","indexedPaths","_indexedpaths","indexes","pathType","singleNestedPath","getPositionalPathType","self","filter","Boolean","isNested","queue","args","pre","remainingArgs","apply","el","post","plugin","opts","deduplicate","method","static","fields","expires","_tags","auto","indexTypes","localField","foreignField","has","_v","$$populatedVirtuals","justOne","count","unset","doc","parts","cur","remnant","join","mem","part","virtualpath","forEach","allKeys","startsWith","_deletePath","pieces","piece","loadClass","virtualsOnly","getPrototypeOf","getOwnPropertyNames","match","getOwnPropertyDescriptor","getters","setters","_getSchema","_this","pathschema","resultPath","$fullPath","search","foundschema","trypath","isArrayFilter","_getPathType","endsWith","_preCompile","module","exports","ObjectId"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/schema.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schematype');\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\nconst VirtualOptions = require('./options/VirtualOptions');\nconst VirtualType = require('./virtualtype');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst idGetter = require('./helpers/schema/idGetter');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst readPref = require('./driver').get().ReadPreference;\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\nconst util = require('util');\n\nlet MongooseTypes;\n\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').\n  middlewareFunctions;\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n *\n * #### Options for Nested Schemas:\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.methodOptions = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/*!\n * Create virtual properties with alias field\n */\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {Array} paths list of paths to pick\n * @param {Object} [options] options to pass to the schema constructor. Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n  const baseOptions = this.base && this.base.options || {};\n\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  options = utils.options({\n    strict: strict,\n    strictQuery: 'strict' in this._userProvidedOptions ?\n      this._userProvidedOptions.strict :\n      'strictQuery' in baseOptions ?\n        baseOptions.strictQuery : strict,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    _id: true,\n    id: true,\n    typeKey: 'type'\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * ####Example:\n *\n *     const options = { discriminatorKey: 'kind' };\n *\n *     const eventSchema = new mongoose.Schema({ time: Date }, options);\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     // ClickedLinkEvent is a special type of Event that has\n *     // a URL.\n *     const ClickedLinkEvent = Event.discriminator('ClickedLink',\n *     new mongoose.Schema({ url: String }, options));\n *\n *     // When you create a generic event, it can't have a URL field...\n *     const genericEvent = new Event({ time: Date.now(), url: 'google.com' });\n *     assert.ok(!genericEvent.url);\n *     // But a ClickedLinkEvent can\n *     const clickedEvent = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\n *     assert.ok(clickedEvent.url);\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the Schema of the discriminated Schema\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.discriminator = function(name, schema) {\n  this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, { [name]: schema });\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {\n        const applyDiscriminators = val[0]._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n      else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {\n        const applyDiscriminators = val._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        const _schema = new Schema(_typeDef);\n        const schemaWrappedPath = Object.assign({}, val, { type: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const addedKeys = Object.keys(obj).\n    map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.on =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `supressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path +\n          '` is from a different copy of the Mongoose module. ' +\n          'Please make sure you\\'re using the same version ' +\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n          'getting this error, please add `new Schema()` around the path: ' +\n          `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path +\n          '` is from a different copy of the Mongoose module. ' +\n          'Please make sure you\\'re using the same version ' +\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n          'getting this error, please add `new Schema()` around the path: ' +\n          `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/*!\n * ignore. Deprecated re: #6405\n */\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n * @see Statics /docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key option name\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\n/**\n * The allowed index types\n *\n * @receiver Schema\n * @static indexTypes\n * @api public\n */\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * @param {String|Array} path\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](/docs/guide.html#virtuals),\n * [statics](/docs/guide.html#statics), and\n * [methods](/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                    !foundschema.schema.$isSingleNested;\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n          const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n          return ret;\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/*!\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](/docs/schematypes.html#strings)\n * - [Number](/docs/schematypes.html#numbers)\n * - [Boolean](/docs/schematypes.html#booleans) | Bool\n * - [Array](/docs/schematypes.html#arrays)\n * - [Buffer](/docs/schematypes.html#buffers)\n * - [Date](/docs/schematypes.html#dates)\n * - [ObjectId](/docs/schematypes.html#objectids) | Oid\n * - [Mixed](/docs/schematypes.html#mixed)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}