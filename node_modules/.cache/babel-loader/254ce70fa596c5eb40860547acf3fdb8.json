{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\n\nconst MongooseError = require('../../error/mongooseError');\n\nconst StrictModeError = require('../../error/strict');\n\nconst ValidationError = require('../../error/validation');\n\nconst castNumber = require('../../cast/number');\n\nconst cast = require('../../cast');\n\nconst getConstructorName = require('../getConstructorName');\n\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\n\nconst handleImmutable = require('./handleImmutable');\n\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\n\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\n\nconst setDottedPath = require('../path/setDottedPath');\n\nconst utils = require('../../utils');\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n */\n\n\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n\n  options = options || {}; // Update pipeline\n\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n\n    return obj;\n  }\n\n  if (schema.options.strict === 'throw' && obj.hasOwnProperty(schema.options.discriminatorKey)) {\n    throw new StrictModeError(schema.options.discriminatorKey);\n  } else if (!options.overwriteDiscriminatorKey) {\n    delete obj[schema.options.discriminatorKey];\n  }\n\n  if (options.upsert && !options.overwrite) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n  filter = filter || {};\n\n  while (i--) {\n    const op = ops[i]; // if overwrite is set, don't do any of the special $set stuff\n\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  } // cast each value\n\n\n  i = ops.length;\n\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n\n    if (val && typeof val === 'object' && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. ' + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    return {\n      $setOnInsert: filter\n    };\n  }\n\n  return ret;\n};\n/*!\n * ignore\n */\n\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' + ' a string or an array of strings');\n    }\n\n    return val;\n  }\n\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n\n    return val;\n  }\n\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Object} options\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n  let aggregatedError = null;\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key]; // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    if (schema.discriminatorMapping != null && key === schema.options.discriminatorKey && !options.overwriteDiscriminatorKey) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + key + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, key, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n\n            try {\n              obj[key] = schematype.castForQuery(val, context, {\n                strict: _strict\n              });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if (op === '$currentDate' || op in castOps && schematype) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = prefix + key;\n\n        const v = schema._getPathType(pathToCheck);\n\n        let _strict = strict;\n\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        } // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n\n\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;\n      }\n    } else {\n      const checkPath = key === '$each' || key === '$or' || key === '$and' || key === '$in' ? pref : prefix + key;\n      schematype = schema._getSchema(checkPath); // You can use `$setOnInsert` with immutable keys\n\n      if (op !== '$setOnInsert' && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath); // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = {\n              $each: obj[key]\n            };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n/*!\n * ignore\n */\n\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n/*!\n * These ops require no casting because the RHS doesn't do anything.\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n\n    return val;\n  } // console.log('CastUpdateVal', path, op, val, schema);\n\n\n  const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));\n\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n\n    let arrayDepth = 0;\n    let _val = val;\n\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQueryWrapper({\n        val: val,\n        context: context\n      });\n    }\n\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {\n        $type: val.$type\n      };\n    }\n\n    return Boolean(val);\n  }\n\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQueryWrapper({\n      $conditional: $conditional,\n      val: val,\n      context: context\n    });\n  }\n\n  if (overwriteOps[op]) {\n    return schema.castForQueryWrapper({\n      val: val,\n      context: context,\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/),\n      $applySetters: schema[schemaMixedSymbol] != null\n    });\n  }\n\n  return schema.castForQueryWrapper({\n    val: val,\n    context: context\n  });\n}","map":{"version":3,"names":["CastError","require","MongooseError","StrictModeError","ValidationError","castNumber","cast","getConstructorName","getEmbeddedDiscriminatorPath","handleImmutable","moveImmutableProperties","schemaMixedSymbol","setDottedPath","utils","module","exports","castUpdate","schema","obj","options","context","filter","undefined","Array","isArray","len","length","i","ops","Object","keys","op","castPipelineOperator","strict","hasOwnProperty","discriminatorKey","overwriteDiscriminatorKey","upsert","overwrite","ret","val","hasDollarKey","$set","splice","indexOf","push","startsWith","Buffer","isBuffer","walkUpdatePath","msg","Error","isEmptyObject","$setOnInsert","find","v","pref","prefix","hasKeys","schematype","key","aggregatedError","strictMode","_getSchema","discriminatorMapping","err","_appendError","_res","caster","castOps","$each","castUpdateVal","error","$slice","$sort","$position","$isSingleNested","_strict","castForQuery","pathToCheck","_getPathType","pathType","isObject","checkPath","pathDetails","type","isStrict","skip","test","virtuals","$isMongooseArray","query","multipleCastError","addError","numberOps","$pop","$inc","noCastOps","$unset","$push","$addToSet","overwriteOps","$conditional","path","cond","schemaArrayDepth","cur","arrayDepth","_val","additionalNesting","tmp","applySetters","castForQueryWrapper","$type","Boolean","$skipQueryCastForUpdate","$fullPath","match","$applySetters"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\n\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (schema.options.strict === 'throw' && obj.hasOwnProperty(schema.options.discriminatorKey)) {\n    throw new StrictModeError(schema.options.discriminatorKey);\n  } else if (!options.overwriteDiscriminatorKey) {\n    delete obj[schema.options.discriminatorKey];\n  }\n  if (options.upsert && !options.overwrite) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        (!overwrite || hasDollarKey)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    return { $setOnInsert: filter };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Object} options\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    if (schema.discriminatorMapping != null && key === schema.options.discriminatorKey && !options.overwriteDiscriminatorKey) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + key + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, key, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          !options.overwrite &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          !options.overwrite &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/*!\n * These ops require no casting because the RHS doesn't do anything.\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQueryWrapper({\n        val: val,\n        context: context\n      });\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQueryWrapper({\n      $conditional: $conditional,\n      val: val,\n      context: context\n    });\n  }\n\n  if (overwriteOps[op]) {\n    return schema.castForQueryWrapper({\n      val: val,\n      context: context,\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/),\n      $applySetters: schema[schemaMixedSymbol] != null\n    });\n  }\n\n  return schema.castForQueryWrapper({ val: val, context: context });\n}\n"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,kBAAD,CAAzB;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,oBAAD,CAA/B;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,wBAAD,CAA/B;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,mBAAD,CAA1B;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,YAAD,CAApB;;AACA,MAAMM,kBAAkB,GAAGN,OAAO,CAAC,uBAAD,CAAlC;;AACA,MAAMO,4BAA4B,GAAGP,OAAO,CAAC,gCAAD,CAA5C;;AACA,MAAMQ,eAAe,GAAGR,OAAO,CAAC,mBAAD,CAA/B;;AACA,MAAMS,uBAAuB,GAAGT,OAAO,CAAC,mCAAD,CAAvC;;AACA,MAAMU,iBAAiB,GAAGV,OAAO,CAAC,sBAAD,CAAP,CAAgCU,iBAA1D;;AACA,MAAMC,aAAa,GAAGX,OAAO,CAAC,uBAAD,CAA7B;;AACA,MAAMY,KAAK,GAAGZ,OAAO,CAAC,aAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAa,MAAM,CAACC,OAAP,GAAiB,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,GAA5B,EAAiCC,OAAjC,EAA0CC,OAA1C,EAAmDC,MAAnD,EAA2D;EAC1E,IAAIH,GAAG,IAAI,IAAX,EAAiB;IACf,OAAOI,SAAP;EACD;;EACDH,OAAO,GAAGA,OAAO,IAAI,EAArB,CAJ0E,CAK1E;;EACA,IAAII,KAAK,CAACC,OAAN,CAAcN,GAAd,CAAJ,EAAwB;IACtB,MAAMO,GAAG,GAAGP,GAAG,CAACQ,MAAhB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyB,EAAEE,CAA3B,EAA8B;MAC5B,MAAMC,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYZ,GAAG,CAACS,CAAD,CAAf,CAAZ;;MACA,KAAK,MAAMI,EAAX,IAAiBH,GAAjB,EAAsB;QACpBV,GAAG,CAACS,CAAD,CAAH,CAAOI,EAAP,IAAaC,oBAAoB,CAACD,EAAD,EAAKb,GAAG,CAACS,CAAD,CAAH,CAAOI,EAAP,CAAL,CAAjC;MACD;IACF;;IACD,OAAOb,GAAP;EACD;;EAED,IAAID,MAAM,CAACE,OAAP,CAAec,MAAf,KAA0B,OAA1B,IAAqCf,GAAG,CAACgB,cAAJ,CAAmBjB,MAAM,CAACE,OAAP,CAAegB,gBAAlC,CAAzC,EAA8F;IAC5F,MAAM,IAAIhC,eAAJ,CAAoBc,MAAM,CAACE,OAAP,CAAegB,gBAAnC,CAAN;EACD,CAFD,MAEO,IAAI,CAAChB,OAAO,CAACiB,yBAAb,EAAwC;IAC7C,OAAOlB,GAAG,CAACD,MAAM,CAACE,OAAP,CAAegB,gBAAhB,CAAV;EACD;;EACD,IAAIhB,OAAO,CAACkB,MAAR,IAAkB,CAAClB,OAAO,CAACmB,SAA/B,EAA0C;IACxC5B,uBAAuB,CAACO,MAAD,EAASC,GAAT,EAAcE,OAAd,CAAvB;EACD;;EAED,MAAMQ,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYZ,GAAZ,CAAZ;EACA,IAAIS,CAAC,GAAGC,GAAG,CAACF,MAAZ;EACA,MAAMa,GAAG,GAAG,EAAZ;EACA,IAAIC,GAAJ;EACA,IAAIC,YAAY,GAAG,KAAnB;EACA,MAAMH,SAAS,GAAGnB,OAAO,CAACmB,SAA1B;EAEAjB,MAAM,GAAGA,MAAM,IAAI,EAAnB;;EACA,OAAOM,CAAC,EAAR,EAAY;IACV,MAAMI,EAAE,GAAGH,GAAG,CAACD,CAAD,CAAd,CADU,CAEV;;IACA,IAAII,EAAE,CAAC,CAAD,CAAF,KAAU,GAAV,IAAiB,CAACO,SAAtB,EAAiC;MAC/B;MACA,IAAI,CAACC,GAAG,CAACG,IAAT,EAAe;QACb,IAAIxB,GAAG,CAACwB,IAAR,EAAc;UACZH,GAAG,CAACG,IAAJ,GAAWxB,GAAG,CAACwB,IAAf;QACD,CAFD,MAEO;UACLH,GAAG,CAACG,IAAJ,GAAW,EAAX;QACD;MACF;;MACDH,GAAG,CAACG,IAAJ,CAASX,EAAT,IAAeb,GAAG,CAACa,EAAD,CAAlB;MACAH,GAAG,CAACe,MAAJ,CAAWhB,CAAX,EAAc,CAAd;MACA,IAAI,CAAC,CAACC,GAAG,CAACgB,OAAJ,CAAY,MAAZ,CAAN,EAA2BhB,GAAG,CAACiB,IAAJ,CAAS,MAAT;IAC5B,CAZD,MAYO,IAAId,EAAE,KAAK,MAAX,EAAmB;MACxB,IAAI,CAACQ,GAAG,CAACG,IAAT,EAAe;QACbH,GAAG,CAACR,EAAD,CAAH,GAAUb,GAAG,CAACa,EAAD,CAAb;MACD;IACF,CAJM,MAIA;MACLQ,GAAG,CAACR,EAAD,CAAH,GAAUb,GAAG,CAACa,EAAD,CAAb;IACD;EACF,CAxDyE,CAyD1E;;;EACAJ,CAAC,GAAGC,GAAG,CAACF,MAAR;;EACA,OAAOC,CAAC,EAAR,EAAY;IACV,MAAMI,EAAE,GAAGH,GAAG,CAACD,CAAD,CAAd;IACAa,GAAG,GAAGD,GAAG,CAACR,EAAD,CAAT;IACAU,YAAY,GAAGA,YAAY,IAAIV,EAAE,CAACe,UAAH,CAAc,GAAd,CAA/B;;IAEA,IAAIN,GAAG,IACH,OAAOA,GAAP,KAAe,QADf,IAEA,CAACO,MAAM,CAACC,QAAP,CAAgBR,GAAhB,CAFD,KAGC,CAACF,SAAD,IAAcG,YAHf,CAAJ,EAGkC;MAChCQ,cAAc,CAAChC,MAAD,EAASuB,GAAT,EAAcT,EAAd,EAAkBZ,OAAlB,EAA2BC,OAA3B,EAAoCC,MAApC,CAAd;IACD,CALD,MAKO,IAAIiB,SAAS,IAAIC,GAAb,IAAoB,OAAOA,GAAP,KAAe,QAAvC,EAAiD;MACtDU,cAAc,CAAChC,MAAD,EAASsB,GAAT,EAAc,MAAd,EAAsBpB,OAAtB,EAA+BC,OAA/B,EAAwCC,MAAxC,CAAd;IACD,CAFM,MAEA;MACL,MAAM6B,GAAG,GAAG,qCAAqCnB,EAArC,GAA0C,IAA1C,GACN,+BADM,GAC4B,OAAOS,GAD/C;MAEA,MAAM,IAAIW,KAAJ,CAAUD,GAAV,CAAN;IACD;;IAED,IAAInB,EAAE,CAACe,UAAH,CAAc,GAAd,KAAsBjC,KAAK,CAACuC,aAAN,CAAoBZ,GAApB,CAA1B,EAAoD;MAClD,OAAOD,GAAG,CAACR,EAAD,CAAV;IACD;EACF;;EAED,IAAIF,MAAM,CAACC,IAAP,CAAYS,GAAZ,EAAiBb,MAAjB,KAA4B,CAA5B,IACAP,OAAO,CAACkB,MADR,IAEAR,MAAM,CAACC,IAAP,CAAYT,MAAZ,EAAoBK,MAApB,GAA6B,CAFjC,EAEoC;IAClC;IACA;IACA,OAAO;MAAE2B,YAAY,EAAEhC;IAAhB,CAAP;EACD;;EACD,OAAOkB,GAAP;AACD,CA1FD;AA4FA;AACA;AACA;;;AAEA,SAASP,oBAAT,CAA8BD,EAA9B,EAAkCS,GAAlC,EAAuC;EACrC,IAAIT,EAAE,KAAK,QAAX,EAAqB;IACnB,IAAI,OAAOS,GAAP,KAAe,QAAf,KAA4B,CAACjB,KAAK,CAACC,OAAN,CAAcgB,GAAd,CAAD,IAAuBA,GAAG,CAACc,IAAJ,CAASC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAA3B,CAAnD,CAAJ,EAA8F;MAC5F,MAAM,IAAIrD,aAAJ,CAAkB,yCACtB,kCADI,CAAN;IAED;;IACD,OAAOsC,GAAP;EACD;;EACD,IAAIT,EAAE,KAAK,UAAX,EAAuB;IACrB,IAAIS,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAP,KAAe,QAAlC,EAA4C;MAC1C,MAAM,IAAItC,aAAJ,CAAkB,iDAAlB,CAAN;IACD;;IACD,OAAOsC,GAAP;EACD;;EACD,IAAIT,EAAE,KAAK,YAAP,IAAuBA,EAAE,KAAK,MAAlC,EAA0C;IACxC,IAAIS,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAP,KAAe,QAAlC,EAA4C;MAC1C,MAAM,IAAItC,aAAJ,CAAkB,aAAa6B,EAAb,GAAkB,iCAApC,CAAN;IACD;;IACD,OAAOS,GAAP;EACD,CALD,MAKO,IAAIT,EAAE,KAAK,cAAP,IAAyBA,EAAE,KAAK,cAApC,EAAoD;IACzD,IAAIS,GAAG,IAAI,IAAP,IAAe,OAAOA,GAAP,KAAe,QAAlC,EAA4C;MAC1C,MAAM,IAAItC,aAAJ,CAAkB,aAAa6B,EAAb,GAAkB,iCAApC,CAAN;IACD;;IACD,OAAOS,GAAP;EACD;;EAED,MAAM,IAAItC,aAAJ,CAAkB,wCAAwC6B,EAAxC,GAA6C,GAA/D,CAAN;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASkB,cAAT,CAAwBhC,MAAxB,EAAgCC,GAAhC,EAAqCa,EAArC,EAAyCZ,OAAzC,EAAkDC,OAAlD,EAA2DC,MAA3D,EAAmEmC,IAAnE,EAAyE;EACvE,MAAMvB,MAAM,GAAGd,OAAO,CAACc,MAAvB;EACA,MAAMwB,MAAM,GAAGD,IAAI,GAAGA,IAAI,GAAG,GAAV,GAAgB,EAAnC;EACA,MAAM1B,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYZ,GAAZ,CAAb;EACA,IAAIS,CAAC,GAAGG,IAAI,CAACJ,MAAb;EACA,IAAIgC,OAAO,GAAG,KAAd;EACA,IAAIC,UAAJ;EACA,IAAIC,GAAJ;EACA,IAAIpB,GAAJ;EAEA,IAAIqB,eAAe,GAAG,IAAtB;EAEA,MAAMC,UAAU,GAAG7B,MAAM,IAAI,IAAV,GAAiBA,MAAjB,GAA0BhB,MAAM,CAACE,OAAP,CAAec,MAA5D;;EAEA,OAAON,CAAC,EAAR,EAAY;IACViC,GAAG,GAAG9B,IAAI,CAACH,CAAD,CAAV;IACAa,GAAG,GAAGtB,GAAG,CAAC0C,GAAD,CAAT,CAFU,CAIV;IACA;;IACA,IAAI7B,EAAE,KAAK,OAAX,EAAoB;MAClB4B,UAAU,GAAG1C,MAAM,CAAC8C,UAAP,CAAkBN,MAAM,GAAGG,GAA3B,CAAb;;MACA,IAAID,UAAU,IAAI,IAAd,IAAsBA,UAAU,CAAC1C,MAAX,IAAqB,IAA/C,EAAqD;QACnDC,GAAG,CAAC0C,GAAD,CAAH,GAAWtD,IAAI,CAACqD,UAAU,CAAC1C,MAAZ,EAAoBC,GAAG,CAAC0C,GAAD,CAAvB,EAA8BzC,OAA9B,EAAuCC,OAAvC,CAAf;QACAsC,OAAO,GAAG,IAAV;QACA;MACD;IACF;;IAED,IAAIzC,MAAM,CAAC+C,oBAAP,IAA+B,IAA/B,IAAuCJ,GAAG,KAAK3C,MAAM,CAACE,OAAP,CAAegB,gBAA9D,IAAkF,CAAChB,OAAO,CAACiB,yBAA/F,EAA0H;MACxH,IAAI0B,UAAU,KAAK,OAAnB,EAA4B;QAC1B,MAAMG,GAAG,GAAG,IAAId,KAAJ,CAAU,sCAAsCS,GAAtC,GAA4C,0BAAtD,CAAZ;QACAC,eAAe,GAAGK,YAAY,CAACD,GAAD,EAAM7C,OAAN,EAAewC,GAAf,EAAoBC,eAApB,CAA9B;QACA;MACD,CAJD,MAIO,IAAIC,UAAJ,EAAgB;QACrB,OAAO5C,GAAG,CAAC0C,GAAD,CAAV;QACA;MACD;IACF;;IAED,IAAIrD,kBAAkB,CAACiC,GAAD,CAAlB,KAA4B,QAAhC,EAA0C;MACxC;MACAmB,UAAU,GAAG1C,MAAM,CAAC8C,UAAP,CAAkBN,MAAM,GAAGG,GAA3B,CAAb;;MAEA,IAAID,UAAU,IAAI,IAAlB,EAAwB;QACtB,MAAMQ,IAAI,GAAG3D,4BAA4B,CAACS,MAAD,EAASC,GAAT,EAAcG,MAAd,EAAsBoC,MAAM,GAAGG,GAA/B,EAAoCzC,OAApC,CAAzC;;QACA,IAAIgD,IAAI,CAACR,UAAL,IAAmB,IAAvB,EAA6B;UAC3BA,UAAU,GAAGQ,IAAI,CAACR,UAAlB;QACD;MACF;;MAED,IAAI5B,EAAE,KAAK,cAAP,IACA,CAACZ,OAAO,CAACmB,SADT,IAEA7B,eAAe,CAACkD,UAAD,EAAa1B,MAAb,EAAqBf,GAArB,EAA0B0C,GAA1B,EAA+BH,MAAM,GAAGG,GAAxC,EAA6CxC,OAA7C,CAFnB,EAE0E;QACxE;MACD;;MAED,IAAIuC,UAAU,IAAIA,UAAU,CAACS,MAAzB,IAAmCrC,EAAE,IAAIsC,OAA7C,EAAsD;QACpD;QACA,IAAI,WAAW7B,GAAf,EAAoB;UAClBkB,OAAO,GAAG,IAAV;;UACA,IAAI;YACFxC,GAAG,CAAC0C,GAAD,CAAH,GAAW;cACTU,KAAK,EAAEC,aAAa,CAACZ,UAAD,EAAanB,GAAG,CAAC8B,KAAjB,EAAwBvC,EAAxB,EAA4B6B,GAA5B,EAAiCxC,OAAjC,EAA0CqC,MAAM,GAAGG,GAAnD;YADX,CAAX;UAGD,CAJD,CAIE,OAAOY,KAAP,EAAc;YACdX,eAAe,GAAGK,YAAY,CAACM,KAAD,EAAQpD,OAAR,EAAiBwC,GAAjB,EAAsBC,eAAtB,CAA9B;UACD;;UAED,IAAIrB,GAAG,CAACiC,MAAJ,IAAc,IAAlB,EAAwB;YACtBvD,GAAG,CAAC0C,GAAD,CAAH,CAASa,MAAT,GAAkBjC,GAAG,CAACiC,MAAJ,GAAa,CAA/B;UACD;;UAED,IAAIjC,GAAG,CAACkC,KAAR,EAAe;YACbxD,GAAG,CAAC0C,GAAD,CAAH,CAASc,KAAT,GAAiBlC,GAAG,CAACkC,KAArB;UACD;;UAED,IAAIlC,GAAG,CAACmC,SAAJ,IAAiB,IAArB,EAA2B;YACzBzD,GAAG,CAAC0C,GAAD,CAAH,CAASe,SAAT,GAAqBtE,UAAU,CAACmC,GAAG,CAACmC,SAAL,CAA/B;UACD;QACF,CArBD,MAqBO;UACL,IAAIhB,UAAU,IAAI,IAAd,IAAsBA,UAAU,CAACiB,eAArC,EAAsD;YACpD,MAAMC,OAAO,GAAG5C,MAAM,IAAI,IAAV,GAAiB0B,UAAU,CAAC1C,MAAX,CAAkBE,OAAlB,CAA0Bc,MAA3C,GAAoDA,MAApE;;YACA,IAAI;cACFf,GAAG,CAAC0C,GAAD,CAAH,GAAWD,UAAU,CAACmB,YAAX,CAAwBtC,GAAxB,EAA6BpB,OAA7B,EAAsC;gBAAEa,MAAM,EAAE4C;cAAV,CAAtC,CAAX;YACD,CAFD,CAEE,OAAOL,KAAP,EAAc;cACdX,eAAe,GAAGK,YAAY,CAACM,KAAD,EAAQpD,OAAR,EAAiBwC,GAAjB,EAAsBC,eAAtB,CAA9B;YACD;UACF,CAPD,MAOO;YACL,IAAI;cACF3C,GAAG,CAAC0C,GAAD,CAAH,GAAWW,aAAa,CAACZ,UAAD,EAAanB,GAAb,EAAkBT,EAAlB,EAAsB6B,GAAtB,EAA2BxC,OAA3B,EAAoCqC,MAAM,GAAGG,GAA7C,CAAxB;YACD,CAFD,CAEE,OAAOY,KAAP,EAAc;cACdX,eAAe,GAAGK,YAAY,CAACM,KAAD,EAAQpD,OAAR,EAAiBwC,GAAjB,EAAsBC,eAAtB,CAA9B;YACD;UACF;;UAED,IAAI3C,GAAG,CAAC0C,GAAD,CAAH,KAAa,KAAK,CAAtB,EAAyB;YACvB,OAAO1C,GAAG,CAAC0C,GAAD,CAAV;YACA;UACD;;UAEDF,OAAO,GAAG,IAAV;QACD;MACF,CA9CD,MA8CO,IAAK3B,EAAE,KAAK,cAAR,IAA4BA,EAAE,IAAIsC,OAAN,IAAiBV,UAAjD,EAA8D;QACnE;QACA,IAAI;UACFzC,GAAG,CAAC0C,GAAD,CAAH,GAAWW,aAAa,CAACZ,UAAD,EAAanB,GAAb,EAAkBT,EAAlB,EAAsB6B,GAAtB,EAA2BxC,OAA3B,EAAoCqC,MAAM,GAAGG,GAA7C,CAAxB;QACD,CAFD,CAEE,OAAOY,KAAP,EAAc;UACdX,eAAe,GAAGK,YAAY,CAACM,KAAD,EAAQpD,OAAR,EAAiBwC,GAAjB,EAAsBC,eAAtB,CAA9B;QACD;;QAED,IAAI3C,GAAG,CAAC0C,GAAD,CAAH,KAAa,KAAK,CAAtB,EAAyB;UACvB,OAAO1C,GAAG,CAAC0C,GAAD,CAAV;UACA;QACD;;QAEDF,OAAO,GAAG,IAAV;MACD,CAdM,MAcA;QACL,MAAMqB,WAAW,GAAItB,MAAM,GAAGG,GAA9B;;QACA,MAAML,CAAC,GAAGtC,MAAM,CAAC+D,YAAP,CAAoBD,WAApB,CAAV;;QACA,IAAIF,OAAO,GAAG5C,MAAd;;QACA,IAAIsB,CAAC,IAAIA,CAAC,CAACtC,MAAP,IAAiB4D,OAAO,IAAI,IAAhC,EAAsC;UACpCA,OAAO,GAAGtB,CAAC,CAACtC,MAAF,CAASE,OAAT,CAAiBc,MAA3B;QACD;;QAED,IAAIsB,CAAC,CAAC0B,QAAF,KAAe,WAAnB,EAAgC;UAC9B,IAAIJ,OAAO,KAAK,OAAhB,EAAyB;YACvB,MAAM,IAAI1E,eAAJ,CAAoB4E,WAApB,CAAN;UACD,CAFD,MAEO,IAAIF,OAAJ,EAAa;YAClB,OAAO3D,GAAG,CAAC0C,GAAD,CAAV;YACA;UACD;QACF,CAfI,CAiBL;QACA;QACA;;;QACAF,OAAO,IAAIT,cAAc,CAAChC,MAAD,EAASuB,GAAT,EAAcT,EAAd,EAAkBZ,OAAlB,EAA2BC,OAA3B,EAAoCC,MAApC,EAA4CoC,MAAM,GAAGG,GAArD,CAAd,IACR/C,KAAK,CAACqE,QAAN,CAAe1C,GAAf,KAAuBX,MAAM,CAACC,IAAP,CAAYU,GAAZ,EAAiBd,MAAjB,KAA4B,CADtD;MAED;IACF,CApGD,MAoGO;MACL,MAAMyD,SAAS,GAAIvB,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,KAA3B,IAAoCA,GAAG,KAAK,MAA5C,IAAsDA,GAAG,KAAK,KAA/D,GAChBJ,IADgB,GACTC,MAAM,GAAGG,GADlB;MAEAD,UAAU,GAAG1C,MAAM,CAAC8C,UAAP,CAAkBoB,SAAlB,CAAb,CAHK,CAKL;;MACA,IAAIpD,EAAE,KAAK,cAAP,IACA,CAACZ,OAAO,CAACmB,SADT,IAEA7B,eAAe,CAACkD,UAAD,EAAa1B,MAAb,EAAqBf,GAArB,EAA0B0C,GAA1B,EAA+BH,MAAM,GAAGG,GAAxC,EAA6CxC,OAA7C,CAFnB,EAE0E;QACxE;MACD;;MAED,IAAIgE,WAAW,GAAGnE,MAAM,CAAC+D,YAAP,CAAoBG,SAApB,CAAlB,CAZK,CAcL;MACA;;;MACA,IAAIxB,UAAU,IAAI,IAAlB,EAAwB;QACtB,MAAMQ,IAAI,GAAG3D,4BAA4B,CAACS,MAAD,EAASC,GAAT,EAAcG,MAAd,EAAsB8D,SAAtB,EAAiChE,OAAjC,CAAzC;;QACA,IAAIgD,IAAI,CAACR,UAAL,IAAmB,IAAvB,EAA6B;UAC3BA,UAAU,GAAGQ,IAAI,CAACR,UAAlB;UACAyB,WAAW,GAAGjB,IAAI,CAACkB,IAAnB;QACD;MACF;;MAED,IAAIC,QAAQ,GAAGrD,MAAf;;MACA,IAAImD,WAAW,IAAIA,WAAW,CAACnE,MAA3B,IAAqCgB,MAAM,IAAI,IAAnD,EAAyD;QACvDqD,QAAQ,GAAGF,WAAW,CAACnE,MAAZ,CAAmBE,OAAnB,CAA2Bc,MAAtC;MACD;;MAED,MAAMsD,IAAI,GAAGD,QAAQ,IACnB,CAAC3B,UADU,IAEX,CAAC,cAAc6B,IAAd,CAAmBJ,WAAW,CAACH,QAA/B,CAFH;;MAIA,IAAIM,IAAJ,EAAU;QACR;QACA;QACA,IAAID,QAAQ,KAAK,OAAb,IAAwBrE,MAAM,CAACwE,QAAP,CAAgBN,SAAhB,KAA8B,IAA1D,EAAgE;UAC9D,MAAM,IAAIhF,eAAJ,CAAoBsD,MAAM,GAAGG,GAA7B,CAAN;QACD,CAFD,MAEO;UACL,OAAO1C,GAAG,CAAC0C,GAAD,CAAV;QACD;MACF,CARD,MAQO;QACL;QACA;QACA,IAAI7B,EAAE,KAAK,SAAX,EAAsB;UACpB2B,OAAO,GAAG,IAAV;UACA;QACD;;QAED,IAAI;UACF,IAAID,MAAM,CAAC/B,MAAP,KAAkB,CAAlB,IAAuBkC,GAAG,CAAChB,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CAAjD,EAAoD;YAClD1B,GAAG,CAAC0C,GAAD,CAAH,GAAWW,aAAa,CAACZ,UAAD,EAAanB,GAAb,EAAkBT,EAAlB,EAAsB6B,GAAtB,EAA2BxC,OAA3B,EAAoCqC,MAAM,GAAGG,GAA7C,CAAxB;UACD,CAFD,MAEO;YACL;YACA;YACA;YACAhD,aAAa,CAACM,GAAD,EAAM0C,GAAN,EAAWW,aAAa,CAACZ,UAAD,EAAanB,GAAb,EAAkBT,EAAlB,EAAsB6B,GAAtB,EAA2BxC,OAA3B,EAAoCqC,MAAM,GAAGG,GAA7C,CAAxB,CAAb;YACA,OAAO1C,GAAG,CAAC0C,GAAD,CAAV;UACD;QACF,CAVD,CAUE,OAAOY,KAAP,EAAc;UACdX,eAAe,GAAGK,YAAY,CAACM,KAAD,EAAQpD,OAAR,EAAiBwC,GAAjB,EAAsBC,eAAtB,CAA9B;QACD;;QAED,IAAItC,KAAK,CAACC,OAAN,CAAcN,GAAG,CAAC0C,GAAD,CAAjB,MAA4B7B,EAAE,KAAK,WAAP,IAAsBA,EAAE,KAAK,OAAzD,KAAqE6B,GAAG,KAAK,OAAjF,EAA0F;UACxF,IAAID,UAAU,IACVA,UAAU,CAACS,MADX,IAEA,CAACT,UAAU,CAACS,MAAX,CAAkBsB,gBAFnB,IAGA,CAAC/B,UAAU,CAACS,MAAX,CAAkBzD,iBAAlB,CAHL,EAG2C;YACzCO,GAAG,CAAC0C,GAAD,CAAH,GAAW;cAAEU,KAAK,EAAEpD,GAAG,CAAC0C,GAAD;YAAZ,CAAX;UACD;QACF;;QAED,IAAI1C,GAAG,CAAC0C,GAAD,CAAH,KAAa,KAAK,CAAtB,EAAyB;UACvB,OAAO1C,GAAG,CAAC0C,GAAD,CAAV;UACA;QACD;;QAEDF,OAAO,GAAG,IAAV;MACD;IACF;EACF;;EAED,IAAIG,eAAe,IAAI,IAAvB,EAA6B;IAC3B,MAAMA,eAAN;EACD;;EAED,OAAOH,OAAP;AACD;AAED;AACA;AACA;;;AAEA,SAASQ,YAAT,CAAsBM,KAAtB,EAA6BmB,KAA7B,EAAoC/B,GAApC,EAAyCC,eAAzC,EAA0D;EACxD,IAAI,OAAO8B,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAK,CAACxE,OAAN,CAAcyE,iBAAhD,EAAmE;IACjE,MAAMpB,KAAN;EACD;;EACDX,eAAe,GAAGA,eAAe,IAAI,IAAIzD,eAAJ,EAArC;EACAyD,eAAe,CAACgC,QAAhB,CAAyBjC,GAAzB,EAA8BY,KAA9B;EACA,OAAOX,eAAP;AACD;AAED;AACA;AACA;AACA;;;AAEA,MAAMiC,SAAS,GAAG;EAChBC,IAAI,EAAE,CADU;EAEhBC,IAAI,EAAE;AAFU,CAAlB;AAKA;AACA;AACA;;AAEA,MAAMC,SAAS,GAAG;EAChBC,MAAM,EAAE;AADQ,CAAlB;AAIA;AACA;AACA;AACA;;AAEA,MAAM7B,OAAO,GAAG;EACd8B,KAAK,EAAE,CADO;EAEdC,SAAS,EAAE,CAFG;EAGd1D,IAAI,EAAE,CAHQ;EAIdW,YAAY,EAAE;AAJA,CAAhB;AAOA;AACA;AACA;;AAEA,MAAMgD,YAAY,GAAG;EACnB3D,IAAI,EAAE,CADa;EAEnBW,YAAY,EAAE;AAFK,CAArB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASkB,aAAT,CAAuBtD,MAAvB,EAA+BuB,GAA/B,EAAoCT,EAApC,EAAwCuE,YAAxC,EAAsDlF,OAAtD,EAA+DmF,IAA/D,EAAqE;EACnE,IAAI,CAACtF,MAAL,EAAa;IACX;IACA,IAAIc,EAAE,IAAI+D,SAAV,EAAqB;MACnB,IAAI;QACF,OAAOzF,UAAU,CAACmC,GAAD,CAAjB;MACD,CAFD,CAEE,OAAOyB,GAAP,EAAY;QACZ,MAAM,IAAIjE,SAAJ,CAAc,QAAd,EAAwBwC,GAAxB,EAA6B+D,IAA7B,CAAN;MACD;IACF;;IACD,OAAO/D,GAAP;EACD,CAXkE,CAanE;;;EAEA,MAAMgE,IAAI,GAAGvF,MAAM,CAACmD,MAAP,IAAiBrC,EAAE,IAAIsC,OAAvB,KACRxD,KAAK,CAACqE,QAAN,CAAe1C,GAAf,KAAuBjB,KAAK,CAACC,OAAN,CAAcgB,GAAd,CADf,CAAb;;EAEA,IAAIgE,IAAI,IAAI,CAACH,YAAY,CAACtE,EAAD,CAAzB,EAA+B;IAC7B;IACA;IACA,IAAI0E,gBAAgB,GAAG,CAAvB;IACA,IAAIC,GAAG,GAAGzF,MAAV;;IACA,OAAOyF,GAAG,CAAChB,gBAAX,EAA6B;MAC3B,EAAEe,gBAAF;MACAC,GAAG,GAAGA,GAAG,CAACtC,MAAV;IACD;;IACD,IAAIuC,UAAU,GAAG,CAAjB;IACA,IAAIC,IAAI,GAAGpE,GAAX;;IACA,OAAOjB,KAAK,CAACC,OAAN,CAAcoF,IAAd,CAAP,EAA4B;MAC1B,EAAED,UAAF;MACAC,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAX;IACD;;IAED,MAAMC,iBAAiB,GAAGJ,gBAAgB,GAAGE,UAA7C;;IACA,OAAOA,UAAU,GAAGF,gBAApB,EAAsC;MACpCjE,GAAG,GAAG,CAACA,GAAD,CAAN;MACA,EAAEmE,UAAF;IACD;;IAED,IAAIG,GAAG,GAAG7F,MAAM,CAAC8F,YAAP,CAAoBxF,KAAK,CAACC,OAAN,CAAcgB,GAAd,IAAqBA,GAArB,GAA2B,CAACA,GAAD,CAA/C,EAAsDpB,OAAtD,CAAV;;IAEA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkF,iBAApB,EAAuC,EAAElF,CAAzC,EAA4C;MAC1CmF,GAAG,GAAGA,GAAG,CAAC,CAAD,CAAT;IACD;;IACD,OAAOA,GAAP;EACD;;EAED,IAAI/E,EAAE,IAAIkE,SAAV,EAAqB;IACnB,OAAOzD,GAAP;EACD;;EACD,IAAIT,EAAE,IAAI+D,SAAV,EAAqB;IACnB;IACA,IAAItD,GAAG,IAAI,IAAX,EAAiB;MACf,MAAM,IAAIxC,SAAJ,CAAc,QAAd,EAAwBwC,GAAxB,EAA6BvB,MAAM,CAACsF,IAApC,CAAN;IACD;;IACD,IAAIxE,EAAE,KAAK,MAAX,EAAmB;MACjB;MACA,OAAOd,MAAM,CAAC+F,mBAAP,CAA2B;QAChCxE,GAAG,EAAEA,GAD2B;QAEhCpB,OAAO,EAAEA;MAFuB,CAA3B,CAAP;IAID;;IACD,IAAI;MACF,OAAOf,UAAU,CAACmC,GAAD,CAAjB;IACD,CAFD,CAEE,OAAOgC,KAAP,EAAc;MACd,MAAM,IAAIxE,SAAJ,CAAc,QAAd,EAAwBwC,GAAxB,EAA6BvB,MAAM,CAACsF,IAApC,CAAN;IACD;EACF;;EACD,IAAIxE,EAAE,KAAK,cAAX,EAA2B;IACzB,IAAI,OAAOS,GAAP,KAAe,QAAnB,EAA6B;MAC3B,OAAO;QAAEyE,KAAK,EAAEzE,GAAG,CAACyE;MAAb,CAAP;IACD;;IACD,OAAOC,OAAO,CAAC1E,GAAD,CAAd;EACD;;EAED,IAAI,MAAMgD,IAAN,CAAWc,YAAX,CAAJ,EAA8B;IAC5B,OAAOrF,MAAM,CAAC+F,mBAAP,CAA2B;MAChCV,YAAY,EAAEA,YADkB;MAEhC9D,GAAG,EAAEA,GAF2B;MAGhCpB,OAAO,EAAEA;IAHuB,CAA3B,CAAP;EAKD;;EAED,IAAIiF,YAAY,CAACtE,EAAD,CAAhB,EAAsB;IACpB,OAAOd,MAAM,CAAC+F,mBAAP,CAA2B;MAChCxE,GAAG,EAAEA,GAD2B;MAEhCpB,OAAO,EAAEA,OAFuB;MAGhC+F,uBAAuB,EAAE3E,GAAG,IAAI,IAAP,IAAevB,MAAM,CAACyE,gBAAtB,IAA0CzE,MAAM,CAACmG,SAAP,IAAoB,IAA9D,IAAsE,CAACnG,MAAM,CAACmG,SAAP,CAAiBC,KAAjB,CAAuB,MAAvB,CAHhE;MAIhCC,aAAa,EAAErG,MAAM,CAACN,iBAAD,CAAN,IAA6B;IAJZ,CAA3B,CAAP;EAMD;;EAED,OAAOM,MAAM,CAAC+F,mBAAP,CAA2B;IAAExE,GAAG,EAAEA,GAAP;IAAYpB,OAAO,EAAEA;EAArB,CAA3B,CAAP;AACD"},"metadata":{},"sourceType":"script"}