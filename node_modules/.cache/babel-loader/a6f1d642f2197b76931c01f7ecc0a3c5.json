{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\n\nconst immediate = require('../immediate');\n\nconst promiseOrCallback = require('../promiseOrCallback');\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\n\nmodule.exports = function eachAsync(next, fn, options, callback) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n  return promiseOrCallback(callback, cb => {\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate(cb);\n  });\n\n  function iterate(finalCallback) {\n    let drained = false;\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n    let documentsBatch = [];\n    let error = null;\n\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(fetch);\n    }\n\n    function fetch(done) {\n      if (drained || error) {\n        return done();\n      }\n\n      next(function (err, doc) {\n        if (drained || error != null) {\n          return done();\n        }\n\n        if (err != null) {\n          if (continueOnError) {\n            aggregatedErrors.push(err);\n          } else {\n            error = err;\n            finalCallback(err);\n            return done();\n          }\n        }\n\n        if (doc == null) {\n          drained = true;\n\n          if (handleResultsInProgress <= 0) {\n            const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;\n            finalCallback(finalErr);\n          } else if (batchSize && documentsBatch.length) {\n            handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n          }\n\n          return done();\n        }\n\n        ++handleResultsInProgress; // Kick off the subsequent `next()` before handling the result, but\n        // make sure we know that we still have a result to handle re: #8422\n\n        immediate(() => done());\n\n        if (batchSize) {\n          documentsBatch.push(doc);\n        } // If the current documents size is less than the provided patch size don't process the documents yet\n\n\n        if (batchSize && documentsBatch.length !== batchSize) {\n          immediate(() => enqueue(fetch));\n          return;\n        }\n\n        const docsToProcess = batchSize ? documentsBatch : doc;\n\n        function handleNextResultCallBack(err) {\n          if (batchSize) {\n            handleResultsInProgress -= documentsBatch.length;\n            documentsBatch = [];\n          } else {\n            --handleResultsInProgress;\n          }\n\n          if (err != null) {\n            if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              return finalCallback(err);\n            }\n          }\n\n          if (drained && handleResultsInProgress <= 0) {\n            const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;\n            return finalCallback(finalErr);\n          }\n\n          immediate(() => enqueue(fetch));\n        }\n\n        handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n      });\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(function () {\n        callback(null);\n      }, function (error) {\n        callback(error || new Error('`eachAsync()` promise rejected without error'));\n      });\n    } else {\n      callback(null);\n    }\n  }\n}; // `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\n\n\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n  return function enqueue(fn) {\n    if (inProgress === null && _queue.length === 0) {\n      inProgress = id++;\n      return fn(_step);\n    }\n\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n\n      const fn = _queue.shift();\n\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}","map":{"version":3,"names":["EachAsyncMultiError","require","immediate","promiseOrCallback","module","exports","eachAsync","next","fn","options","callback","parallel","batchSize","continueOnError","aggregatedErrors","enqueue","asyncQueue","cb","TypeError","Number","isInteger","iterate","finalCallback","drained","handleResultsInProgress","currentDocumentIndex","documentsBatch","error","i","fetch","done","err","doc","push","finalErr","createEachAsyncMultiError","length","handleNextResult","handleNextResultCallBack","docsToProcess","maybePromise","then","Error","_queue","inProgress","id","_step","shift"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\nconst immediate = require('../immediate');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = function eachAsync(next, fn, options, callback) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  return promiseOrCallback(callback, cb => {\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate(cb);\n  });\n\n  function iterate(finalCallback) {\n    let drained = false;\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n    let documentsBatch = [];\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(fetch);\n    }\n\n    function fetch(done) {\n      if (drained || error) {\n        return done();\n      }\n\n      next(function(err, doc) {\n        if (drained || error != null) {\n          return done();\n        }\n        if (err != null) {\n          if (continueOnError) {\n            aggregatedErrors.push(err);\n          } else {\n            error = err;\n            finalCallback(err);\n            return done();\n          }\n        }\n        if (doc == null) {\n          drained = true;\n          if (handleResultsInProgress <= 0) {\n            const finalErr = continueOnError ?\n              createEachAsyncMultiError(aggregatedErrors) :\n              error;\n\n            finalCallback(finalErr);\n          } else if (batchSize && documentsBatch.length) {\n            handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n          }\n          return done();\n        }\n\n        ++handleResultsInProgress;\n\n        // Kick off the subsequent `next()` before handling the result, but\n        // make sure we know that we still have a result to handle re: #8422\n        immediate(() => done());\n\n        if (batchSize) {\n          documentsBatch.push(doc);\n        }\n\n        // If the current documents size is less than the provided patch size don't process the documents yet\n        if (batchSize && documentsBatch.length !== batchSize) {\n          immediate(() => enqueue(fetch));\n          return;\n        }\n\n        const docsToProcess = batchSize ? documentsBatch : doc;\n\n        function handleNextResultCallBack(err) {\n          if (batchSize) {\n            handleResultsInProgress -= documentsBatch.length;\n            documentsBatch = [];\n          } else {\n            --handleResultsInProgress;\n          }\n          if (err != null) {\n            if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              return finalCallback(err);\n            }\n          }\n          if (drained && handleResultsInProgress <= 0) {\n            const finalErr = continueOnError ?\n              createEachAsyncMultiError(aggregatedErrors) :\n              error;\n            return finalCallback(finalErr);\n          }\n\n          immediate(() => enqueue(fetch));\n        }\n\n        handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n      });\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}