{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\n\nconst SkipPopulateValue = require('./SkipPopulateValue');\n\nconst get = require('../get');\n\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\n\nconst getConstructorName = require('../getConstructorName');\n\nconst getSchemaTypes = require('./getSchemaTypes');\n\nconst getVirtual = require('./getVirtual');\n\nconst lookupLocalFields = require('./lookupLocalFields');\n\nconst mpath = require('mpath');\n\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\n\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n  const modelSchema = model.schema; // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {\n    return new MongooseError('Cannot populate path `' + (options._fullPath || options.path) + '` because it is not in your schema. Set the `strictPopulate` option ' + 'to false to override.');\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path); // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      } // No-op if no `ref` set. See gh-11538\n\n\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n\n      for (const _schema of schemasArray) {\n        let _modelNames;\n\n        let res;\n\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n\n        if (!_modelNames) {\n          continue;\n        }\n\n        modelNames = modelNames || [];\n\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null); // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id'; // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField; // Get local fields\n\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    let match = get(options, 'match', null);\n    const hasMatchFunction = typeof match === 'function';\n\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n\n    if (schema != null && schema[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {\n      return {\n        modelNames: null\n      };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n        modelNames = new Set();\n\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n        }\n\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null && typeof ref === 'function' && options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          modelNames = new Set();\n\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n          }\n\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return {\n          modelNames: modelNames,\n          justOne: justOne,\n          isRefPath: isRefPath,\n          refPath: refPath\n        };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return {\n      modelNames: modelNames,\n      justOne: justOne,\n      isRefPath: isRefPath,\n      refPath: refPath\n    };\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {}; // localField and foreignField\n\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n\n    if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError('If you are populating a virtual, you must set the ' + 'localField and foreignField options');\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false; // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n\n    let justOne = null;\n\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    if (virtual.options.refPath) {\n      modelNames = modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n\n      justOne = !!virtual.options.justOne; // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne; // `match`\n\n    let match = get(options, 'match', null) || get(data, 'virtual.options.match', null) || get(data, 'virtual.options.options.match', null);\n    let hasMatchFunction = typeof match === 'function';\n\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction; // Get local fields\n\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n/*!\n * ignore\n */\n\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n\n  while (k--) {\n    const modelName = modelNames[k];\n\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ? get(options, 'options.perDocumentLimit', null) : options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = utils.clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n\n      utils.merge(currentOptions, options); // Used internally for checking what model was used to populate this\n      // path.\n\n      options[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n/*!\n * ignore\n */\n\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n\n  return ref;\n}\n/*!\n * ignore\n */\n\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n\n  const localFieldPath = localFieldPathType === 'real' ? model.schema.path(localField) : localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ? _populateOptions.getters : get(virtual, 'options.getters', false);\n\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n/*!\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @return {Array|Document|Any}\n */\n\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  } // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n\n\n  if (getConstructorName(val) === 'Object' && ( // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n\n    return ret;\n  } // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n\n\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n/*!\n * ignore\n */\n\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n\n    if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n\n        if (discriminatorSchema == null) {\n          continue;\n        }\n\n        const _path = discriminatorSchema.path(remnant);\n\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","get","getDiscriminatorByValue","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","modelNamesFromRefPath","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","module","exports","getModelsMapForPopulate","model","docs","options","doc","len","length","map","modelNameFromQuery","modelName","schema","refPath","modelNames","available","modelSchema","_localModel","nested","path","_virtualRes","virtual","_virtualPopulate","allSchemaTypes","Array","isArray","filter","v","strictPopulate","_fullPath","i","justOne","docSchema","$__","$__schema","$isMongooseDocumentArray","ref","isUnderneathDocArray","$isUnderneathDocArray","isRefPath","normalizedRefPath","schemaOptions","modelNamesInOrder","instance","data","localField","foreignField","res","_getModelNames","unpopulatedValue","id","addModelNamesToMap","schemasArray","_schema","_modelNames","error","indexOf","push","from","Set","endsWith","every","$isMongooseArray","isVirtual","ret","_getLocalFieldValues","String","getValue","_docs","slice","match","hasMatchFunction","call","embeddedDiscriminatorModelNames","_findRefPathForDiscriminators","err","caster","$isSchemaMap","$__schemaType","subdocPath","vals","subdocsBeingPopulated","array","flatten","subdoc","_queryProjection","forEach","name","add","schemaForCurrentDoc","discriminatorValue","modelForCurrentDoc","discriminatorKey","discriminatorModel","discriminators","_getModelFromConn","db","_getSchema","_arrayPath","handleRefFunction","virtualPrefix","nestedSchemaPath","field","count","skip","hasOwnProperty","limit","perDocumentLimit","normalizedRef","Object","assign","convertTo_id","connection","cloneArrays","k","Model","ids","flat","modelNamesForRefPath","val","currentOptions","clone","merge","allIds","unpopulatedValues","conn","models","_parent","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","_populateOptions","hydratedDoc","hydrate","localFieldValue","localFieldHydratedValue","split","localFieldArrVal","localFieldArrIndex","applyGetters","_id","rawVal","__array","isMongooseArray","$schema","_castForPopulate","$parent","concat","key","keys","Map","values","pieces","cur","piece","schematype","subdocs","remnant","substring","discriminatorName","discriminator","discriminatorSchema","_path","docValue","join"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {\n    return new MongooseError('Cannot populate path `' + (options._fullPath || options.path) +\n      '` because it is not in your schema. Set the `strictPopulate` option ' +\n      'to false to override.');\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError('If you are populating a virtual, you must set the ' +\n        'localField and foreignField options');\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    if (virtual.options.refPath) {\n      modelNames =\n        modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    let match = get(options, 'match', null) ||\n      get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n  while (k--) {\n    const modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = utils.clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/*!\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @return {Array|Document|Any}\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}