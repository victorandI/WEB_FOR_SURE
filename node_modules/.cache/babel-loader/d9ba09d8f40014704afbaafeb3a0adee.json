{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\n\nconst get = require('./helpers/get');\n\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst clone = require('./helpers/clone');\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n  return pop;\n};\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\n\n\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n\n  return new model(undefined, fields, _opts);\n};\n/*!\n * ignore\n */\n\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ? {\n    populated: populatedIds\n  } : undefined;\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n/*!\n * ignore\n */\n\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n\n      const field = fields[keys[keyIndex]]; // Skip `$meta` and `$slice`\n\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n\n      exclude = !field;\n      break;\n    }\n  } // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n\n      break;\n\n    case undefined:\n      if (fields == null) {\n        break;\n      } // Any leftover plus paths must in the schema, so delete them (gh-7017)\n\n\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      } // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n\n\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = ''); // avoid recursion\n\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        return;\n      }\n\n      let addedPath = analyzePath(path, type); // arrays\n\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      } // nested schemas\n\n\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path); // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n\n\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') {\n      return;\n    } // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n\n\n    if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath]; // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    } // check for parent exclusions\n\n\n    const pieces = path.split('.');\n    let cur = '';\n\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    } // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n\n\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}","map":{"version":3,"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","opts","_localModel","model","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","_opts","skipId","isNew","willInit","defaults","createModelAndInit","populatedIds","callback","initOpts","populated","casted","$init","error","exclude","keyIndex","length","field","selected","excluded","stack","analyzeSchema","fieldName","paths","select","_id","startsWith","prefix","indexOf","push","addedPaths","eachPath","type","$isSchemaMap","endsWith","addedPath","analyzePath","Array","isArray","$isMongooseArray","$isMongooseDocumentArray","caster","_addedPaths","plusPath","hasPlusPath","discriminatorKey","pieces","split","cur","i","$skipDiscriminatorCheck","val","option","virtuals","assign","map","slice"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/queryhelpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n"],"mappings":"AAAA;AAEA;AACA;AACA;;AAEA,MAAMA,uCAAuC,GAC3CC,OAAO,CAAC,iEAAD,CADT;;AAEA,MAAMC,GAAG,GAAGD,OAAO,CAAC,eAAD,CAAnB;;AACA,MAAME,uBAAuB,GAC3BF,OAAO,CAAC,iDAAD,CADT;;AAEA,MAAMG,oBAAoB,GAAGH,OAAO,CAAC,2CAAD,CAApC;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,iBAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAK,OAAO,CAACC,wBAAR,GAAmC,SAASA,wBAAT,CAAkCC,KAAlC,EAAyCC,OAAzC,EAAkD;EACnF,MAAMC,SAAS,GAAGF,KAAK,CAACC,OAAN,CAAcE,QAAhC;EACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYJ,SAAZ,EAAuBK,MAAvB,CAA8B,CAACC,IAAD,EAAOC,GAAP,KAAeD,IAAI,CAACE,MAAL,CAAY,CAACR,SAAS,CAACO,GAAD,CAAV,CAAZ,CAA7C,EAA4E,EAA5E,CAAZ,CAFmF,CAInF;;EACA,IAAIR,OAAO,CAACU,IAAR,IAAgB,IAApB,EAA0B;IACxBP,GAAG,CACAQ,MADH,CACUC,CAAC,IAAI,CAACA,CAAC,IAAIA,CAAC,CAACZ,OAAP,IAAkBY,CAAC,CAACZ,OAAF,CAAUU,IAA7B,KAAsC,IADrD,EAEGG,OAFH,CAEWC,QAAQ,CAACd,OAAO,CAACU,IAAT,CAFnB;EAGD;;EAEDP,GAAG,CAACU,OAAJ,CAAYE,IAAI,IAAI;IAClBA,IAAI,CAACC,WAAL,GAAmBjB,KAAK,CAACkB,KAAzB;EACD,CAFD;EAIA,OAAOd,GAAP;AACD,CAhBD;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAN,OAAO,CAACqB,0BAAR,GAAqC,SAASA,0BAAT,CAAoCnB,KAApC,EAA2CC,OAA3C,EAAoD;EACvF,MAAMC,SAAS,GAAGF,KAAK,CAACoB,gBAAN,CAAuBjB,QAAzC;EACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYJ,SAAZ,EAAuBK,MAAvB,CAA8B,CAACC,IAAD,EAAOC,GAAP,KAAeD,IAAI,CAACE,MAAL,CAAY,CAACR,SAAS,CAACO,GAAD,CAAV,CAAZ,CAA7C,EAA4E,EAA5E,CAAZ,CAFuF,CAIvF;;EACA,IAAIR,OAAO,CAACU,IAAR,IAAgB,IAApB,EAA0B;IACxBP,GAAG,CACAQ,MADH,CACUC,CAAC,IAAI,CAACA,CAAC,IAAIA,CAAC,CAACZ,OAAP,IAAkBY,CAAC,CAACZ,OAAF,CAAUU,IAA7B,KAAsC,IADrD,EAEGG,OAFH,CAEWC,QAAQ,CAACd,OAAO,CAACU,IAAT,CAFnB;EAGD;;EAED,MAAMU,OAAO,GAAGrB,KAAK,IAAIA,KAAK,CAACC,OAAf,IAA0BD,KAAK,CAACC,OAAN,CAAcoB,OAAxC,IAAmD,IAAnE;;EACA,IAAIA,OAAO,IAAI,IAAf,EAAqB;IACnBjB,GAAG,CAACU,OAAJ,CAAYQ,IAAI,IAAI;MAClB,IAAIA,IAAI,CAACrB,OAAL,IAAgB,IAApB,EAA0B;QACxBqB,IAAI,CAACrB,OAAL,GAAe;UAAEoB,OAAO,EAAEA;QAAX,CAAf;QACA;MACD;;MACD,IAAI,EAAE,aAAaC,IAAI,CAACrB,OAApB,CAAJ,EAAkC;QAChCqB,IAAI,CAACrB,OAAL,CAAaoB,OAAb,GAAuBA,OAAvB;MACD;IACF,CARD;EASD;;EAED,MAAME,UAAU,GAAGvB,KAAK,CAACwB,cAAN,EAAnB;;EACApB,GAAG,CAACU,OAAJ,CAAYD,CAAC,IAAI;IACfA,CAAC,CAACY,gBAAF,GAAqBF,UAArB;EACD,CAFD;EAGAnB,GAAG,CAACU,OAAJ,CAAYE,IAAI,IAAI;IAClBA,IAAI,CAACC,WAAL,GAAmBjB,KAAK,CAACkB,KAAzB;EACD,CAFD;EAIA,OAAOd,GAAP;AACD,CAjCD;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,OAAO,CAAC4B,WAAR,GAAsB,SAASA,WAAT,CAAqBR,KAArB,EAA4BS,GAA5B,EAAiCC,MAAjC,EAAyCC,kBAAzC,EAA6D5B,OAA7D,EAAsE;EAC1FiB,KAAK,CAACY,KAAN,CAAYC,WAAZ,CAAwB,aAAxB,EAAuCJ,GAAvC;EACA,MAAMK,oBAAoB,GAAGd,KAAK,CAACe,MAAN,GAC3Bf,KAAK,CAACe,MAAN,CAAaD,oBADc,GAE3B,IAFF;EAIA,MAAMvB,GAAG,GAAGuB,oBAAoB,IAAIA,oBAAoB,CAACE,MAA7C,GACVF,oBAAoB,CAACvB,GADX,GAEV,IAFF;EAIA,MAAM0B,KAAK,GAAGR,GAAG,CAAClB,GAAD,CAAjB;;EACA,IAAIA,GAAG,IAAI0B,KAAP,IAAgBjB,KAAK,CAACkB,cAA1B,EAA0C;IACxC,MAAMC,aAAa,GAAGnB,KAAK,CAACkB,cAAN,CAAqBD,KAArB,KAA+BxC,uBAAuB,CAACuB,KAAK,CAACkB,cAAP,EAAuBD,KAAvB,CAA5E;;IACA,IAAIE,aAAJ,EAAmB;MACjB,MAAMC,OAAO,GAAGzC,KAAK,CAACgC,kBAAD,CAArB;;MACA/B,OAAO,CAACyC,UAAR,CAAmBD,OAAnB,EAA4BD,aAAa,CAACJ,MAA1C;MACA,OAAO,IAAII,aAAJ,CAAkBG,SAAlB,EAA6BF,OAA7B,EAAsC,IAAtC,CAAP;IACD;EACF;;EAED,MAAMG,KAAK,GAAG;IACZC,MAAM,EAAE,IADI;IAEZC,KAAK,EAAE,KAFK;IAGZC,QAAQ,EAAE;EAHE,CAAd;;EAKA,IAAI3C,OAAO,IAAI,IAAX,IAAmB,cAAcA,OAArC,EAA8C;IAC5CwC,KAAK,CAACI,QAAN,GAAiB5C,OAAO,CAAC4C,QAAzB;EACD;;EACD,OAAO,IAAI3B,KAAJ,CAAUsB,SAAV,EAAqBZ,MAArB,EAA6Ba,KAA7B,CAAP;AACD,CA7BD;AA+BA;AACA;AACA;;;AAEA3C,OAAO,CAACgD,kBAAR,GAA6B,SAASA,kBAAT,CAA4B5B,KAA5B,EAAmCS,GAAnC,EAAwCC,MAAxC,EAAgDC,kBAAhD,EAAoE5B,OAApE,EAA6E8C,YAA7E,EAA2FC,QAA3F,EAAqG;EAChI,MAAMC,QAAQ,GAAGF,YAAY,GAC3B;IAAEG,SAAS,EAAEH;EAAb,CAD2B,GAE3BP,SAFF;EAIA,MAAMW,MAAM,GAAGrD,OAAO,CAAC4B,WAAR,CAAoBR,KAApB,EAA2BS,GAA3B,EAAgCC,MAAhC,EAAwCC,kBAAxC,EAA4D5B,OAA5D,CAAf;;EACA,IAAI;IACFkD,MAAM,CAACC,KAAP,CAAazB,GAAb,EAAkBsB,QAAlB,EAA4BD,QAA5B;EACD,CAFD,CAEE,OAAOK,KAAP,EAAc;IACdL,QAAQ,CAACK,KAAD,EAAQF,MAAR,CAAR;EACD;AACF,CAXD;AAaA;AACA;AACA;;;AAEArD,OAAO,CAACyC,UAAR,GAAqB,SAASA,UAAT,CAAoBX,MAApB,EAA4BK,MAA5B,EAAoC;EACvD;EACA,IAAIqB,OAAJ;EACA,IAAIhD,IAAJ;EACA,IAAIiD,QAAJ;;EAEA,IAAI3B,MAAJ,EAAY;IACVtB,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYsB,MAAZ,CAAP;IACA2B,QAAQ,GAAGjD,IAAI,CAACkD,MAAhB;;IAEA,OAAOD,QAAQ,EAAf,EAAmB;MACjB,IAAIjD,IAAI,CAACiD,QAAD,CAAJ,CAAe,CAAf,MAAsB,GAA1B,EAA+B;QAC7B;MACD;;MACD,MAAME,KAAK,GAAG7B,MAAM,CAACtB,IAAI,CAACiD,QAAD,CAAL,CAApB,CAJiB,CAKjB;;MACA,IAAI,CAAC3D,oBAAoB,CAAC6D,KAAD,CAAzB,EAAkC;QAChC;MACD;;MACDH,OAAO,GAAG,CAACG,KAAX;MACA;IACD;EACF,CAtBsD,CAwBvD;EACA;;;EAEA,MAAMC,QAAQ,GAAG,EAAjB;EACA,MAAMC,QAAQ,GAAG,EAAjB;EACA,MAAMC,KAAK,GAAG,EAAd;EAEAC,aAAa,CAAC5B,MAAD,CAAb;;EAEA,QAAQqB,OAAR;IACE,KAAK,IAAL;MACE,KAAK,MAAMQ,SAAX,IAAwBH,QAAxB,EAAkC;QAChC/B,MAAM,CAACkC,SAAD,CAAN,GAAoB,CAApB;MACD;;MACD;;IACF,KAAK,KAAL;MACE,IAAI7B,MAAM,IACNA,MAAM,CAAC8B,KAAP,CAAa,KAAb,CADA,IAEA9B,MAAM,CAAC8B,KAAP,CAAa,KAAb,EAAoB9D,OAFpB,IAGAgC,MAAM,CAAC8B,KAAP,CAAa,KAAb,EAAoB9D,OAApB,CAA4B+D,MAA5B,KAAuC,KAH3C,EAGkD;QAChDpC,MAAM,CAACqC,GAAP,GAAa,CAAb;MACD;;MAED,KAAK,MAAMH,SAAX,IAAwBJ,QAAxB,EAAkC;QAChC9B,MAAM,CAACkC,SAAD,CAAN,GAAoBlC,MAAM,CAACkC,SAAD,CAAN,IAAqB,CAAzC;MACD;;MACD;;IACF,KAAKtB,SAAL;MACE,IAAIZ,MAAM,IAAI,IAAd,EAAoB;QAClB;MACD,CAHH,CAIE;;;MACA,KAAK,MAAMnB,GAAX,IAAkBJ,MAAM,CAACC,IAAP,CAAYsB,MAAM,IAAI,EAAtB,CAAlB,EAA6C;QAC3C,IAAInB,GAAG,CAACyD,UAAJ,CAAe,GAAf,CAAJ,EAAyB;UACvB,OAAOtC,MAAM,CAACnB,GAAD,CAAb;QACD;MACF,CATH,CAWE;MACA;;;MACA,KAAK,MAAMqD,SAAX,IAAwBH,QAAxB,EAAkC;QAChC/B,MAAM,CAACkC,SAAD,CAAN,GAAoB,CAApB;MACD;;MACD;EAlCJ;;EAqCA,SAASD,aAAT,CAAuB5B,MAAvB,EAA+BkC,MAA/B,EAAuC;IACrCA,MAAM,KAAKA,MAAM,GAAG,EAAd,CAAN,CADqC,CAGrC;;IACA,IAAIP,KAAK,CAACQ,OAAN,CAAcnC,MAAd,MAA0B,CAAC,CAA/B,EAAkC;MAChC,OAAO,EAAP;IACD;;IACD2B,KAAK,CAACS,IAAN,CAAWpC,MAAX;IAEA,MAAMqC,UAAU,GAAG,EAAnB;IACArC,MAAM,CAACsC,QAAP,CAAgB,UAASjD,IAAT,EAAekD,IAAf,EAAqB;MACnC,IAAIL,MAAJ,EAAY7C,IAAI,GAAG6C,MAAM,GAAG,GAAT,GAAe7C,IAAtB;;MACZ,IAAIkD,IAAI,CAACC,YAAL,IAAqBnD,IAAI,CAACoD,QAAL,CAAc,KAAd,CAAzB,EAA+C;QAC7C;MACD;;MACD,IAAIC,SAAS,GAAGC,WAAW,CAACtD,IAAD,EAAOkD,IAAP,CAA3B,CALmC,CAMnC;;MACA,IAAIG,SAAS,IAAI,IAAb,IAAqB,CAACE,KAAK,CAACC,OAAN,CAAcN,IAAd,CAAtB,IAA6CA,IAAI,CAACO,gBAAlD,IAAsE,CAACP,IAAI,CAACQ,wBAAhF,EAA0G;QACxGL,SAAS,GAAGC,WAAW,CAACtD,IAAD,EAAOkD,IAAI,CAACS,MAAZ,CAAvB;MACD;;MACD,IAAIN,SAAS,IAAI,IAAjB,EAAuB;QACrBL,UAAU,CAACD,IAAX,CAAgBM,SAAhB;MACD,CAZkC,CAcnC;;;MACA,IAAIH,IAAI,CAACvC,MAAT,EAAiB;QACf,MAAMiD,WAAW,GAAGrB,aAAa,CAACW,IAAI,CAACvC,MAAN,EAAcX,IAAd,CAAjC,CADe,CAGf;QACA;;;QACA,IAAIgC,OAAO,KAAK,KAAhB,EAAuB;UACrB9D,uCAAuC,CAACoC,MAAD,EAASN,IAAT,EAAekD,IAAI,CAACvC,MAApB,EACrCyB,QADqC,EAC3BwB,WAD2B,CAAvC;QAED;MACF;IACF,CAzBD;IA0BAtB,KAAK,CAACxD,GAAN;IACA,OAAOkE,UAAP;EACD;;EAED,SAASM,WAAT,CAAqBtD,IAArB,EAA2BkD,IAA3B,EAAiC;IAC/B,MAAMW,QAAQ,GAAG,MAAM7D,IAAvB;IACA,MAAM8D,WAAW,GAAGxD,MAAM,IAAIuD,QAAQ,IAAIvD,MAA1C;;IACA,IAAIwD,WAAJ,EAAiB;MACf;MACA,OAAOxD,MAAM,CAACuD,QAAD,CAAb;IACD;;IAED,IAAI,OAAOX,IAAI,CAACd,QAAZ,KAAyB,SAA7B,EAAwC;MACtC;IACD,CAV8B,CAY/B;IACA;IACA;;;IACA,IAAIJ,OAAO,IAAIkB,IAAI,CAACd,QAAhB,IAA4BpC,IAAI,KAAKW,MAAM,CAAChC,OAAP,CAAeoF,gBAApD,IAAwEzD,MAAM,CAACN,IAAD,CAAN,IAAgB,IAAxF,IAAgG,CAACM,MAAM,CAACN,IAAD,CAA3G,EAAmH;MACjH,OAAOM,MAAM,CAACN,IAAD,CAAb;MACA;IACD;;IAED,IAAI8D,WAAJ,EAAiB;MACf;MACA,OAAOxD,MAAM,CAACuD,QAAD,CAAb,CAFe,CAIf;MACA;;MACA,IAAI7B,OAAO,KAAK,KAAZ,IAAqBhD,IAAI,CAACkD,MAAL,GAAc,CAAnC,IAAwC,CAAC,CAAClD,IAAI,CAAC8D,OAAL,CAAa9C,IAAb,CAA9C,EAAkE;QAChEM,MAAM,CAACN,IAAD,CAAN,GAAe,CAAf;MACD;;MAED;IACD,CA/B8B,CAiC/B;;;IACA,MAAMgE,MAAM,GAAGhE,IAAI,CAACiE,KAAL,CAAW,GAAX,CAAf;IACA,IAAIC,GAAG,GAAG,EAAV;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAAC9B,MAA3B,EAAmC,EAAEiC,CAArC,EAAwC;MACtCD,GAAG,IAAIA,GAAG,CAAChC,MAAJ,GAAa,MAAM8B,MAAM,CAACG,CAAD,CAAzB,GAA+BH,MAAM,CAACG,CAAD,CAA5C;;MACA,IAAI9B,QAAQ,CAACS,OAAT,CAAiBoB,GAAjB,MAA0B,CAAC,CAA/B,EAAkC;QAChC;MACD;IACF,CAzC8B,CA2C/B;IACA;IACA;;;IACA,IAAI,CAAClC,OAAD,KAAakB,IAAI,IAAIA,IAAI,CAACvE,OAAb,IAAwBuE,IAAI,CAACvE,OAAL,CAAayF,uBAArC,IAAgE,KAA7E,CAAJ,EAAyF;MACvF,IAAIF,GAAG,GAAG,EAAV;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAAC9B,MAA3B,EAAmC,EAAEiC,CAArC,EAAwC;QACtCD,GAAG,IAAI,CAACA,GAAG,CAAChC,MAAJ,KAAe,CAAf,GAAmB,EAAnB,GAAwB,GAAzB,IAAgC8B,MAAM,CAACG,CAAD,CAA7C;QACA,MAAMlE,UAAU,GAAG7B,GAAG,CAACkC,MAAD,EAAS4D,GAAT,EAAc,KAAd,CAAH,IAA2B9F,GAAG,CAACkC,MAAD,EAAS4D,GAAG,GAAG,IAAf,EAAqB,KAArB,CAAjD;;QACA,IAAIjE,UAAU,IAAI,OAAOA,UAAP,KAAsB,QAAxC,EAAkD;UAChD;QACD;MACF;IACF;;IAED,CAACiD,IAAI,CAACd,QAAL,GAAgBA,QAAhB,GAA2BC,QAA5B,EAAsCU,IAAtC,CAA2C/C,IAA3C;IACA,OAAOA,IAAP;EACD;AACF,CA1KD;AA4KA;AACA;AACA;AACA;AACA;;;AAEA,SAASP,QAAT,CAAkB4E,GAAlB,EAAuB;EACrB,OAAO,UAASC,MAAT,EAAiB;IACtBA,MAAM,CAAC3F,OAAP,KAAmB2F,MAAM,CAAC3F,OAAP,GAAiB,EAApC;;IAEA,IAAI0F,GAAG,IAAI,IAAP,IAAed,KAAK,CAACC,OAAN,CAAca,GAAG,CAACE,QAAlB,CAAnB,EAAgD;MAC9CF,GAAG,GAAGtF,MAAM,CAACyF,MAAP,CAAc,EAAd,EAAkBH,GAAlB,CAAN;MACAA,GAAG,CAACE,QAAJ,GAAeF,GAAG,CAACE,QAAJ,CACbjF,MADa,CACNU,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAAC4C,UAAL,CAAgB0B,MAAM,CAACtE,IAAP,GAAc,GAA9B,CAD9B,EAEbyE,GAFa,CAETzE,IAAI,IAAIA,IAAI,CAAC0E,KAAL,CAAWJ,MAAM,CAACtE,IAAP,CAAYkC,MAAZ,GAAqB,CAAhC,CAFC,CAAf;IAGD;;IAEDoC,MAAM,CAAC3F,OAAP,CAAeU,IAAf,GAAsBgF,GAAtB;EACD,CAXD;AAYD"},"metadata":{},"sourceType":"script"}