{"ast":null,"code":"'use strict';\n\nconst MongooseMap = require('../../types/map');\n\nconst SkipPopulateValue = require('./SkipPopulateValue');\n\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\n\nconst get = require('../get');\n\nconst getVirtual = require('./getVirtual');\n\nconst leanPopulateMap = require('./leanPopulateMap');\n\nconst lookupLocalFields = require('./lookupLocalFields');\n\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\n\nconst mpath = require('mpath');\n\nconst sift = require('sift').default;\n\nconst utils = require('../../utils');\n\nconst {\n  populateModelSymbol\n} = require('../symbols');\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options')); // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n  const originalIds = [].concat(o.rawIds); // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions); // now update the original documents being populated using the\n  // result structure that contains real documents.\n\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      } // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n\n\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    } // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n\n\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal); // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);\n\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions); // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n\n    let cur = docs[i];\n    const curPath = parts[0];\n\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n\n        cur[parts[j]] = {};\n      }\n\n      cur = cur[parts[j]]; // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = {\n          value: o.unpopulatedValues[i]\n        };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    } // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n\n\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n\n        return 1;\n      });\n    }\n\n    return v.filter(el => el != null).length;\n  }\n\n  return v == null ? 0 : 1;\n}\n/*!\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n */\n\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n\n      if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length; // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n\n    let i = 0;\n\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n\n    return val;\n  } // findOne\n\n\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n/*!\n * Remove _id from `subdoc` if user specified \"lean\" query option\n */\n\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n/*!\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n */\n\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}","map":{"version":3,"names":["MongooseMap","require","SkipPopulateValue","assignRawDocsToIdStructure","get","getVirtual","leanPopulateMap","lookupLocalFields","markArraySubdocsPopulated","mpath","sift","default","utils","populateModelSymbol","module","exports","assignVals","o","userOptions","Object","assign","populateOptions","options","justOne","$nullIfNotFound","isVirtual","populatedModel","originalIds","concat","rawIds","allIds","rawDocs","rawOrder","docs","count","i","setValue","val","_allIds","Array","isArray","ret","doc","_docPopulatedModel","push","length","prototype","pop","apply","valueFilter","_path","path","endsWith","slice","existingVal","originalModel","schema","valueToSet","numDocs","match","filter","originalSchema","isDoc","isMap","Map","isPOJO","_getSchema","_keys","from","keys","reduce","cur","v","set","$__","parent","$populated","allOptions","map","parts","split","curPath","j","isArrayIndex","schematype","$isMongooseArray","model","unpopulatedValues","wasPopulated","value","$isMongooseMap","$__schemaType","some","el","assignmentOpts","userSpecifiedTransform","transform","noop","numValues","subdoc","isPopulatedObject","retainNullValues","maybeRemoveId","originalLimit","rLen","isMongooseArray","excludeId","$__setValue","_doc","_id","obj","has"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/populate/assignVals.js"],"sourcesContent":["'use strict';\n\nconst MongooseMap = require('../../types/map');\nconst SkipPopulateValue = require('./SkipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nconst { populateModelSymbol } = require('../symbols');\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(sift(o.match[i])) :\n        [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    const curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/*!\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/*!\n * Remove _id from `subdoc` if user specified \"lean\" query option\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/*!\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}