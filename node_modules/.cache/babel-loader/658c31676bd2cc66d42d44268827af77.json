{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\n\nconst utils = require('../../utils');\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\n\nmodule.exports = function applyMethods(model, schema) {\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function () {\n        const h = {};\n\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n\n        return h;\n      },\n      configurable: true\n    });\n  }\n\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' + 'named \"' + method + '\"');\n    }\n\n    if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` + 'internally, overwriting it may cause bugs. If you\\'re sure you know ' + 'what you\\'re doing, you can suppress this error by using ' + `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  } // Recursively call `applyMethods()` on child schemas\n\n\n  model.$appliedMethods = true;\n\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};","map":{"version":3,"names":["get","require","utils","module","exports","applyMethods","model","schema","apply","method","Object","defineProperty","prototype","h","k","methods","bind","configurable","keys","fn","tree","hasOwnProperty","Error","reserved","warn","$appliedMethods","key","paths","type","$isSingleNested","caster","$isMongooseDocumentArray","Constructor"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/model/applyMethods.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,aAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,MAA7B,EAAqC;EACpD,SAASC,KAAT,CAAeC,MAAf,EAAuBF,MAAvB,EAA+B;IAC7BG,MAAM,CAACC,cAAP,CAAsBL,KAAK,CAACM,SAA5B,EAAuCH,MAAvC,EAA+C;MAC7CT,GAAG,EAAE,YAAW;QACd,MAAMa,CAAC,GAAG,EAAV;;QACA,KAAK,MAAMC,CAAX,IAAgBP,MAAM,CAACQ,OAAP,CAAeN,MAAf,CAAhB,EAAwC;UACtCI,CAAC,CAACC,CAAD,CAAD,GAAOP,MAAM,CAACQ,OAAP,CAAeN,MAAf,EAAuBK,CAAvB,EAA0BE,IAA1B,CAA+B,IAA/B,CAAP;QACD;;QACD,OAAOH,CAAP;MACD,CAP4C;MAQ7CI,YAAY,EAAE;IAR+B,CAA/C;EAUD;;EACD,KAAK,MAAMR,MAAX,IAAqBC,MAAM,CAACQ,IAAP,CAAYX,MAAM,CAACQ,OAAnB,CAArB,EAAkD;IAChD,MAAMI,EAAE,GAAGZ,MAAM,CAACQ,OAAP,CAAeN,MAAf,CAAX;;IACA,IAAIF,MAAM,CAACa,IAAP,CAAYC,cAAZ,CAA2BZ,MAA3B,CAAJ,EAAwC;MACtC,MAAM,IAAIa,KAAJ,CAAU,0DACd,SADc,GACFb,MADE,GACO,GADjB,CAAN;IAED;;IACD,IAAIF,MAAM,CAACgB,QAAP,CAAgBd,MAAhB,KACA,CAACT,GAAG,CAACO,MAAD,EAAU,iBAAgBE,MAAO,kBAAjC,EAAoD,KAApD,CADR,EACoE;MAClEP,KAAK,CAACsB,IAAN,CAAY,8BAA6Bf,MAAO,wBAArC,GACT,sEADS,GAET,2DAFS,GAGR,oBAAmBA,MAAO,sCAH7B;IAID;;IACD,IAAI,OAAOU,EAAP,KAAc,UAAlB,EAA8B;MAC5Bb,KAAK,CAACM,SAAN,CAAgBH,MAAhB,IAA0BU,EAA1B;IACD,CAFD,MAEO;MACLX,KAAK,CAACC,MAAD,EAASF,MAAT,CAAL;IACD;EACF,CA/BmD,CAiCpD;;;EACAD,KAAK,CAACmB,eAAN,GAAwB,IAAxB;;EACA,KAAK,MAAMC,GAAX,IAAkBhB,MAAM,CAACQ,IAAP,CAAYX,MAAM,CAACoB,KAAnB,CAAlB,EAA6C;IAC3C,MAAMC,IAAI,GAAGrB,MAAM,CAACoB,KAAP,CAAaD,GAAb,CAAb;;IACA,IAAIE,IAAI,CAACC,eAAL,IAAwB,CAACD,IAAI,CAACE,MAAL,CAAYL,eAAzC,EAA0D;MACxDpB,YAAY,CAACuB,IAAI,CAACE,MAAN,EAAcF,IAAI,CAACrB,MAAnB,CAAZ;IACD;;IACD,IAAIqB,IAAI,CAACG,wBAAL,IAAiC,CAACH,IAAI,CAACI,WAAL,CAAiBP,eAAvD,EAAwE;MACtEpB,YAAY,CAACuB,IAAI,CAACI,WAAN,EAAmBJ,IAAI,CAACrB,MAAxB,CAAZ;IACD;EACF;AACF,CA5CD"},"metadata":{},"sourceType":"script"}