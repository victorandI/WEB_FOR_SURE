{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst download_1 = require(\"./download\");\n\nconst upload_1 = require(\"./upload\");\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\n\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = { ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, options);\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n\n\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, { ...options,\n      id\n    });\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n\n\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, options);\n  }\n\n  delete(id, callback) {\n    return (0, utils_1.maybePromise)(callback, callback => {\n      return this.s._filesCollection.deleteOne({\n        _id: id\n      }, (error, res) => {\n        if (error) {\n          return callback(error);\n        }\n\n        return this.s._chunksCollection.deleteMany({\n          files_id: id\n        }, error => {\n          if (error) {\n            return callback(error);\n          } // Delete orphaned chunks before returning FileNotFound\n\n\n          if (!(res === null || res === void 0 ? void 0 : res.deletedCount)) {\n            // TODO(NODE-3483): Replace with more appropriate error\n            // Consider creating new error MongoGridFSFileNotFoundError\n            return callback(new error_1.MongoRuntimeError(`File not found for id ${id}`));\n          }\n\n          return callback();\n        });\n      });\n    });\n  }\n  /** Convenience wrapper around find on the files collection */\n\n\n  find(filter, options) {\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n\n\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, { ...options,\n      sort,\n      skip\n    });\n  }\n\n  rename(id, filename, callback) {\n    return (0, utils_1.maybePromise)(callback, callback => {\n      const filter = {\n        _id: id\n      };\n      const update = {\n        $set: {\n          filename\n        }\n      };\n      return this.s._filesCollection.updateOne(filter, update, (error, res) => {\n        if (error) {\n          return callback(error);\n        }\n\n        if (!(res === null || res === void 0 ? void 0 : res.matchedCount)) {\n          return callback(new error_1.MongoRuntimeError(`File with id ${id} not found`));\n        }\n\n        return callback();\n      });\n    });\n  }\n\n  drop(callback) {\n    return (0, utils_1.maybePromise)(callback, callback => {\n      return this.s._filesCollection.drop(error => {\n        if (error) {\n          return callback(error);\n        }\n\n        return this.s._chunksCollection.drop(error => {\n          if (error) {\n            return callback(error);\n          }\n\n          return callback();\n        });\n      });\n    });\n  }\n  /** Get the Db scoped logger. */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n}\n\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\n\nGridFSBucket.INDEX = 'index';","map":{"version":3,"mappings":"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","names":["DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","GridFSBucket","mongo_types_1","constructor","db","options","setMaxListeners","privateOptions","writeConcern","write_concern_1","fromOptions","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","openUploadStream","filename","upload_1","openUploadStreamWithId","id","openDownloadStream","download_1","readPreference","_id","delete","callback","deleteOne","error","res","deleteMany","files_id","deletedCount","error_1","find","filter","openDownloadStreamByName","sort","uploadDate","skip","undefined","revision","rename","update","$set","updateOne","matchedCount","drop","getLogger","logger","exports"],"sources":["B:\\web_project_react\\web_car_react\\node_modules\\mongodb\\src\\gridfs\\index.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport type { Collection } from '../collection';\nimport type { FindCursor } from '../cursor/find_cursor';\nimport type { Db } from '../db';\nimport { MongoRuntimeError } from '../error';\nimport type { Logger } from '../logger';\nimport { Filter, TypedEventEmitter } from '../mongo_types';\nimport type { ReadPreference } from '../read_preference';\nimport type { Sort } from '../sort';\nimport { Callback, maybePromise } from '../utils';\nimport { WriteConcern, WriteConcernOptions } from '../write_concern';\nimport type { FindOptions } from './../operations/find';\nimport {\n  GridFSBucketReadStream,\n  GridFSBucketReadStreamOptions,\n  GridFSBucketReadStreamOptionsWithRevision,\n  GridFSFile\n} from './download';\nimport { GridFSBucketWriteStream, GridFSBucketWriteStreamOptions, GridFSChunk } from './upload';\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS: {\n  bucketName: string;\n  chunkSizeBytes: number;\n} = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n\n/** @public */\nexport interface GridFSBucketOptions extends WriteConcernOptions {\n  /** The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot. */\n  bucketName?: string;\n  /** Number of bytes stored in each chunk. Defaults to 255KB */\n  chunkSizeBytes?: number;\n  /** Read preference to be passed to read operations */\n  readPreference?: ReadPreference;\n}\n\n/** @internal */\nexport interface GridFSBucketPrivate {\n  db: Db;\n  options: {\n    bucketName: string;\n    chunkSizeBytes: number;\n    readPreference?: ReadPreference;\n    writeConcern: WriteConcern | undefined;\n  };\n  _chunksCollection: Collection<GridFSChunk>;\n  _filesCollection: Collection<GridFSFile>;\n  checkedIndexes: boolean;\n  calledOpenUploadStream: boolean;\n}\n\n/** @public */\nexport type GridFSBucketEvents = {\n  index(): void;\n};\n\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nexport class GridFSBucket extends TypedEventEmitter<GridFSBucketEvents> {\n  /** @internal */\n  s: GridFSBucketPrivate;\n\n  /**\n   * When the first call to openUploadStream is made, the upload stream will\n   * check to see if it needs to create the proper indexes on the chunks and\n   * files collections. This event is fired either when 1) it determines that\n   * no index creation is necessary, 2) when it successfully creates the\n   * necessary indexes.\n   * @event\n   */\n  static readonly INDEX = 'index' as const;\n\n  constructor(db: Db, options?: GridFSBucketOptions) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = {\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection<GridFSChunk>(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection<GridFSFile>(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n  openUploadStream(\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, options);\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n  openUploadStreamWithId(\n    id: ObjectId,\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, { ...options, id });\n  }\n\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(\n    id: ObjectId,\n    options?: GridFSBucketReadStreamOptions\n  ): GridFSBucketReadStream {\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { _id: id },\n      options\n    );\n  }\n\n  /**\n   * Deletes a file with the given id\n   *\n   * @param id - The id of the file doc\n   */\n  delete(id: ObjectId): Promise<void>;\n  delete(id: ObjectId, callback: Callback<void>): void;\n  delete(id: ObjectId, callback?: Callback<void>): Promise<void> | void {\n    return maybePromise(callback, callback => {\n      return this.s._filesCollection.deleteOne({ _id: id }, (error, res) => {\n        if (error) {\n          return callback(error);\n        }\n\n        return this.s._chunksCollection.deleteMany({ files_id: id }, error => {\n          if (error) {\n            return callback(error);\n          }\n\n          // Delete orphaned chunks before returning FileNotFound\n          if (!res?.deletedCount) {\n            // TODO(NODE-3483): Replace with more appropriate error\n            // Consider creating new error MongoGridFSFileNotFoundError\n            return callback(new MongoRuntimeError(`File not found for id ${id}`));\n          }\n\n          return callback();\n        });\n      });\n    });\n  }\n\n  /** Convenience wrapper around find on the files collection */\n  find(filter?: Filter<GridFSFile>, options?: FindOptions): FindCursor<GridFSFile> {\n    filter ??= {};\n    options = options ?? {};\n    return this.s._filesCollection.find(filter, options);\n  }\n\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n  openDownloadStreamByName(\n    filename: string,\n    options?: GridFSBucketReadStreamOptionsWithRevision\n  ): GridFSBucketReadStream {\n    let sort: Sort = { uploadDate: -1 };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = { uploadDate: 1 };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { filename },\n      { ...options, sort, skip }\n    );\n  }\n\n  /**\n   * Renames the file with the given _id to the given string\n   *\n   * @param id - the id of the file to rename\n   * @param filename - new name for the file\n   */\n  rename(id: ObjectId, filename: string): Promise<void>;\n  rename(id: ObjectId, filename: string, callback: Callback<void>): void;\n  rename(id: ObjectId, filename: string, callback?: Callback<void>): Promise<void> | void {\n    return maybePromise(callback, callback => {\n      const filter = { _id: id };\n      const update = { $set: { filename } };\n      return this.s._filesCollection.updateOne(filter, update, (error?, res?) => {\n        if (error) {\n          return callback(error);\n        }\n\n        if (!res?.matchedCount) {\n          return callback(new MongoRuntimeError(`File with id ${id} not found`));\n        }\n\n        return callback();\n      });\n    });\n  }\n\n  /** Removes this bucket's files collection, followed by its chunks collection. */\n  drop(): Promise<void>;\n  drop(callback: Callback<void>): void;\n  drop(callback?: Callback<void>): Promise<void> | void {\n    return maybePromise(callback, callback => {\n      return this.s._filesCollection.drop(error => {\n        if (error) {\n          return callback(error);\n        }\n        return this.s._chunksCollection.drop(error => {\n          if (error) {\n            return callback(error);\n          }\n\n          return callback();\n        });\n      });\n    });\n  }\n\n  /** Get the Db scoped logger. */\n  getLogger(): Logger {\n    return this.s.db.s.logger;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}