{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\n\nconst StrictModeError = require('../../error/strict');\n\nconst castNumber = require('../../cast/number');\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([// avoid casting '$add' or '$subtract', because expressions can be either number or date,\n// and we don't have a good way of inferring which arguments should be numbers and which should\n// be dates.\n'$multiply', '$divide', '$log', '$mod', '$trunc', '$avg', '$max', '$min', '$stdDevPop', '$stdDevSamp', '$sum']);\nconst arithmeticOperatorNumber = new Set(['$abs', '$exp', '$ceil', '$floor', '$ln', '$log10', '$round', '$sqrt', '$sin', '$cos', '$tan', '$asin', '$acos', '$atan', '$atan2', '$asinh', '$acosh', '$atanh', '$sinh', '$cosh', '$tanh', '$degreesToRadians', '$radiansToDegrees']);\nconst arrayElementOperators = new Set(['$arrayElemAt', '$first', '$last']);\nconst dateOperators = new Set(['$year', '$month', '$week', '$dayOfMonth', '$dayOfYear', '$hour', '$minute', '$second', '$isoDayOfWeek', '$isoWeekYear', '$isoWeek', '$millisecond']);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  if (isPath(val)) {\n    // Assume path\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\n    val.default = _castExpression(val.default, schema, strictQuery);\n  }\n\n  const keys = Object.keys(val);\n\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n\n  _omitUndefined(val);\n\n  return val;\n}\n\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    val[keys[i]] === void 0 && delete val[keys[i]];\n  }\n} // { $op: <number> }\n\n\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n\n  if (!isPath(path)) {\n    return val;\n  }\n\n  const search = val[0];\n  const schematype = schema.path(path.slice(1));\n\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search), path];\n} // { $op: [<number>, <number>] }\n\n\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n} // { $op: [expression, expression] }\n\n\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = {\n          $literal: schematype.cast(val[1].$literal)\n        };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = {\n            $literal: caster(val[1].$literal)\n          };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://docs.mongodb.com/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n\n  return true;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","castNumber","booleanComparison","Set","comparisonOperator","arithmeticOperatorArray","arithmeticOperatorNumber","arrayElementOperators","dateOperators","expressionOperator","module","exports","cast$expr","val","schema","strictQuery","Error","_castExpression","isPath","$cond","Array","isArray","map","expr","if","then","else","$ifNull","v","$switch","branches","default","keys","Object","key","has","castComparison","castArithmetic","castNumberOperator","$in","castIn","$size","_omitUndefined","i","len","length","isLiteral","err","path","search","schematype","slice","$isMongooseArray","$isMongooseDocumentArray","$embeddedSchemaType","cast","caster","lhs","is$literal","$literal","name","replace","find"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/query/cast$expr.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$round',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  if (isPath(val)) {\n    // Assume path\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\n    val.default = _castExpression(val.default, schema, strictQuery);\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n\n  _omitUndefined(val);\n\n  return val;\n}\n\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    (val[keys[i]] === void 0) && delete val[keys[i]];\n  }\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://docs.mongodb.com/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}