{"ast":null,"code":"/*!\n * Module dependencies.\n */\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\n\nconst Readable = require('stream').Readable;\n\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\n\nconst eachAsync = require('../helpers/cursor/eachAsync');\n\nconst immediate = require('../helpers/immediate');\n\nconst util = require('util');\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](/docs/api.html#aggregate_Aggregate-cursor) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, {\n    autoDestroy: true,\n    objectMode: true\n  });\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function () {\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function () {\n      model.hooks.execPre('aggregate', agg, function () {\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n/*!\n * Necessary to satisfy the Readable API\n */\n\n\nAggregationCursor.prototype._read = function () {\n  const _this = this;\n\n  _next(this, function (error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n\n    if (!doc) {\n      _this.push(null);\n\n      _this.cursor.close(function (error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n\n      return;\n    }\n\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' + 'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function () {\n    throw new MongooseError(msg);\n  };\n}\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @api public\n * @method map\n */\n\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function (fn) {\n    this._transforms.push(fn);\n\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n/*!\n * Marks this cursor as errored\n */\n\nAggregationCursor.prototype._markError = function (error) {\n  this._error = error;\n  return this;\n};\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close https://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\n\nAggregationCursor.prototype.close = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n\n      this.emit('close');\n      cb(null);\n    });\n  });\n};\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\n\nAggregationCursor.prototype.next = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    _next(this, cb);\n  });\n};\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\n\nAggregationCursor.prototype.eachAsync = function (fn, opts, callback) {\n  const _this = this;\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  return eachAsync(function (cb) {\n    return _next(_this, cb);\n  }, fn, opts, callback);\n};\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function () {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n/*!\n * ignore\n */\n\n\nAggregationCursor.prototype._transformForAsyncIterator = function () {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nAggregationCursor.prototype.transformNull = function (val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? {\n    done: true\n  } : {\n    value: doc,\n    done: false\n  };\n}\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\n\nAggregationCursor.prototype.addCursorFlag = function (flag, value) {\n  const _this = this;\n\n  _waitForCursor(this, function () {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n\n  ctx.once('cursor', function () {\n    cb();\n  });\n}\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n\n  if (ctx._transforms.length) {\n    callback = function (err, doc) {\n      if (err || doc === null && !ctx._mongooseOptions.transformNull) {\n        return cb(err, doc);\n      }\n\n      cb(err, ctx._transforms.reduce(function (doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function () {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next(function (error, doc) {\n      if (error) {\n        return callback(error);\n      }\n\n      if (!doc) {\n        return callback(null, null);\n      }\n\n      callback(null, doc);\n    });\n  } else {\n    ctx.once('cursor', function () {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;","map":{"version":3,"names":["MongooseError","require","Readable","promiseOrCallback","eachAsync","immediate","util","AggregationCursor","agg","call","autoDestroy","objectMode","cursor","_transforms","model","_model","options","useMongooseAggCursor","_mongooseOptions","_init","inherits","c","collection","buffer","hooks","execPre","aggregate","_pipeline","emit","emitter","once","prototype","_read","_this","_next","error","doc","push","close","Symbol","asyncIterator","msg","Object","defineProperty","value","fn","enumerable","configurable","writable","_markError","_error","callback","cb","listeners","length","next","opts","transformNull","_transformForAsyncIterator","indexOf","map","val","arguments","done","addCursorFlag","flag","_waitForCursor","ctx","err","reduce","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/cursor/AggregationCursor.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst Readable = require('stream').Readable;\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst immediate = require('../helpers/immediate');\nconst util = require('util');\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](/docs/api.html#aggregate_Aggregate-cursor) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function() {\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg, function() {\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/*!\n * Necessary to satisfy the Readable API\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' +\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/*!\n * Marks this cursor as errored\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close https://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\nAggregationCursor.prototype.close = function(callback) {\n  return promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n      this.emit('close');\n      cb(null);\n    });\n  });\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = function(callback) {\n  return promiseOrCallback(callback, cb => {\n    _next(this, cb);\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next(function(error, doc) {\n      if (error) {\n        return callback(error);\n      }\n      if (!doc) {\n        return callback(null, null);\n      }\n\n      callback(null, doc);\n    });\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}