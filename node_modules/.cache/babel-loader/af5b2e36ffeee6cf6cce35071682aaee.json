{"ast":null,"code":"'use strict';\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\n\nconst get = require('../get');\n\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\n\nconst leanPopulateMap = require('./leanPopulateMap');\n\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n/*!\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n */\n\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;\n\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' + foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).reduce(function (cur, discriminator) {\n            const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n\n            if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n              cur.push(discriminators[discriminator]);\n            }\n\n            return cur;\n          }, []);\n        } // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n\n\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            } // comments.$.comments.$.title\n\n\n            ret = search(parts.slice(p + 1), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n            }\n\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n\n            for (const schema of schemas) {\n              const _ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n\n              if (_ret != null) {\n                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n\n                if (_ret.$isUnderneathDocArray) {\n                  ret.$isUnderneathDocArray = true;\n                }\n\n                ret.push(_ret);\n              }\n            }\n\n            return ret;\n          } else {\n            ret = search(parts.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n            }\n\n            return ret;\n          }\n        } else if (p !== parts.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(parts.slice(p), type.schema, null, nestedPath.concat(parts.slice(0, p)));\n\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n\n        if (model != null) {\n          const ret = search(parts.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !model.schema.$isSingleNested;\n          }\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val); // Populated using lean, `leanPopulateMap` value is the foreign model\n\n        const schema = model != null ? model.schema : null;\n\n        if (schema != null) {\n          const ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n\n          if (ret != null) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !schema.$isSingleNested;\n            return ret;\n          }\n        }\n      }\n\n      return foundschema;\n    }\n  } // look for arrays\n\n\n  const parts = path.split('.');\n\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n\n  return search(parts, schema, doc, []);\n};","map":{"version":3,"names":["Mixed","require","get","getDiscriminatorByValue","leanPopulateMap","mpath","populateModelSymbol","module","exports","getSchemaTypes","model","schema","doc","path","pathschema","topLevelDoc","discriminatorKey","discriminatorMapping","key","discriminator","discriminators","Object","keys","reduce","arr","name","disc","concat","search","parts","subdoc","nestedPath","p","length","foundschema","trypath","slice","join","caster","schemas","discriminatorKeyPath","options","cur","tiedValue","value","indexOf","push","ret","$isUnderneathDocArray","$isSingleNested","_ret","$isMongooseArray","casterConstructor","type","$isMongooseDocumentArray","discriminatorPaths","discriminatorName","_schema","fullPath","$__","$populated","populated","_val","Array","isArray","split","i"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/*!\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n                if (_ret.$isUnderneathDocArray) {\n                  ret.$isUnderneathDocArray = true;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !model.schema.$isSingleNested;\n          }\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !schema.$isSingleNested;\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}