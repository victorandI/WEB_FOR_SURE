{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst commands_1 = require(\"./commands\");\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kHello = Symbol('hello');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kFullResult = Symbol('fullResult');\n/** @internal */\n\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    }); // hook the message stream up to the passed in stream\n\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get hello() {\n    return this[kHello];\n  } // the `connect` method stores the result of the handshake hello on the connection\n\n\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kHello] = response;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n\n  onError(error) {\n    if (this.closed) {\n      return;\n    }\n\n    this[kStream].destroy(error);\n    this.closed = true;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(error);\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onClose() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    const message = `connection ${this.id} to ${this.address} closed`;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(new error_1.MongoNetworkError(message));\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onTimeout() {\n    if (this.closed) {\n      return;\n    }\n\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      this[kStream].destroy();\n      this.closed = true;\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n\n      for (const op of this[kQueue].values()) {\n        op.cb(new error_1.MongoNetworkTimeoutError(message, {\n          beforeHandshake\n        }));\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    } // always emit the message, in case we are streaming\n\n\n    this.emit('message', message);\n    const operationDescription = this[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    this[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      this[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      this[kStream].setTimeout(this.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = (0, sessions_1.applySession)(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  query(ns, cmd, options, callback) {\n    var _a;\n\n    const isExplain = cmd.$explain != null;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      secondaryOk: readPreference.secondaryOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(this, query, {\n      [kFullResult]: true,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n\n      callback(undefined, result);\n    });\n  }\n\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = (0, shared_1.applyCommonQueryOptions)({}, Object.assign(options, { ...(0, bson_1.pluckBSONSerializeOptions)(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      getMoreCmd.comment = options.comment;\n    }\n\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if ((0, utils_1.maxWireVersion)(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback( // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n\n      callback(undefined, response.documents[0]);\n    });\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\n\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\n\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\n\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\n\nConnection.PINNED = constants_1.PINNED;\n/** @event */\n\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"mappings":"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","names":["kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kFullResult","kDelayedTimeoutId","Connection","mongo_types_1","constructor","stream","options","id","address","streamIdentifier","socketTimeoutMS","_a","monitorCommands","serverApi","closed","destroyed","stream_description_1","generation","Map","message_stream_1","maxBsonMessageSize","hello","_b","on","message","onMessage","error","onError","onClose","onTimeout","pipe","description","response","receiveResponse","Object","freeze","serviceId","loadBalanced","idleTime","clusterTime","markAvailable","destroy","op","values","cb","clear","emit","CLOSE","error_1","setTimeout","beforeHandshake","unref","delayedTimeoutId","clearTimeout","operationDescription","get","responseTo","callback","delete","moreToCome","set","requestId","socketTimeoutOverride","parse","err","documents","document","session","$clusterTime","CLUSTER_TIME_RECEIVED","command","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","force","removeAllListeners","PINNED","UNPINNED","assign","end","ns","cmd","utils_1","readPreference","shouldUseOpMsg","supportsOpMsg","finalCmd","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","secondaryOk","cmdNs","db","commands_1","write","query","isExplain","$explain","read_preference_1","primary","batchSize","limit","skip","Math","abs","queryOptions","pre32Limit","projection","returnFieldSelector","toString","tailable","oplogReplay","timeout","noCursorTimeout","awaitData","partial","result","getMore","cursorId","wireVersion","getMoreOp","cursor","nextBatch","getMoreCmd","collection","maxAwaitTimeMS","maxTimeMS","comment","documentsReturnedIn","killCursors","cursorIds","Array","isArray","noResponse","cursors","cursorNotFound","length","exports","constants_1","CryptoConnection","autoEncrypter","serverWireVersion","encrypt","encrypted","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","proxyHost","hostAddress","remoteAddress","remotePort","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","COMMAND_STARTED","command_monitoring_events_1","reply","COMMAND_FAILED","COMMAND_SUCCEEDED","writeCommand","e"],"sources":["B:\\web_project_react\\web_car_react\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { BSONSerializeOptions, Document, Long, ObjectId, pluckBSONSerializeOptions } from '../bson';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  MESSAGE,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport type { AutoEncrypter } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoWriteConcernError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport { applySession, ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  calculateDurationInMs,\n  Callback,\n  ClientMetadata,\n  HostAddress,\n  maxWireVersion,\n  MongoDBNamespace,\n  now,\n  uuidV4\n} from '../utils';\nimport type { WriteConcern } from '../write_concern';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport {\n  BinMsg,\n  GetMore,\n  KillCursor,\n  Msg,\n  OpQueryOptions,\n  Query,\n  Response,\n  WriteProtocolMessageType\n} from './commands';\nimport type { Stream } from './connect';\nimport { MessageStream, OperationDescription } from './message_stream';\nimport { StreamDescription, StreamDescriptionOptions } from './stream_description';\nimport { applyCommonQueryOptions, getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kFullResult = Symbol('fullResult');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n\n/** @internal */\nexport interface QueryOptions extends BSONSerializeOptions {\n  readPreference: ReadPreference;\n  documentsReturnedIn?: string;\n  batchSize?: number;\n  limit?: number;\n  skip?: number;\n  projection?: Document;\n  tailable?: boolean;\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** @deprecated use `noCursorTimeout` instead */\n  timeout?: boolean;\n  partial?: boolean;\n  oplogReplay?: boolean;\n}\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  command?: boolean;\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  raw?: boolean;\n  monitoring?: boolean;\n  [kFullResult]?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\n  // from executeOperation that the txnNum should be applied to this command.\n  // Applying a session to a command should happen as part of command construction,\n  // most likely in the CommandOperation#executeCommand method, where we have access to\n  // the details we need to determine if a txnNum should also be applied.\n  willRetryWrite?: boolean;\n\n  writeConcern?: WriteConcern;\n}\n\n/** @internal */\nexport interface GetMoreOptions extends CommandOptions {\n  batchSize?: number;\n  maxTimeMS?: number;\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  // Settings\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: typeof Connection;\n  credentials?: MongoCredentials;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  keepAlive?: boolean;\n  keepAliveInitialDelay?: number;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n\n  metadata: ClientMetadata;\n}\n\n/** @public */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force?: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  message(message: any): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  closed: boolean;\n  destroyed: boolean;\n  lastHelloMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n\n  /**@internal */\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  [kStream]: Stream;\n  /** @internal */\n  [kHello]: Document | null;\n  /** @internal */\n  [kClusterTime]: Document | null;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly MESSAGE = MESSAGE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n\n    this[kDelayedTimeoutId] = null;\n\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get hello(): Document | null {\n    return this[kHello];\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response: Document | null) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n\n  get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation: number) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document | null {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this[kStream];\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  onError(error: Error) {\n    if (this.closed) {\n      return;\n    }\n\n    this[kStream].destroy(error);\n\n    this.closed = true;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(error);\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onClose() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const message = `connection ${this.id} to ${this.address} closed`;\n    for (const op of this[kQueue].values()) {\n      op.cb(new MongoNetworkError(message));\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onTimeout() {\n    if (this.closed) {\n      return;\n    }\n\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      this[kStream].destroy();\n\n      this.closed = true;\n\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      for (const op of this[kQueue].values()) {\n        op.cb(new MongoNetworkTimeoutError(message, { beforeHandshake }));\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message: BinMsg | Response) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    const operationDescription = this[kQueue].get(message.responseTo);\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      this[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      this[kStream].setTimeout(this.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  }\n\n  destroy(options?: DestroyOptions, callback?: Callback): void {\n    if (typeof options === 'function') {\n      callback = options;\n      options = { force: false };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    if (!(ns instanceof MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = applySession(session, finalCmd, options as CommandOptions);\n      if (err) {\n        return callback(err);\n      }\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      },\n      options\n    );\n\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg\n      ? new Msg(cmdNs, finalCmd, commandOptions)\n      : new Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  query(ns: MongoDBNamespace, cmd: Document, options: QueryOptions, callback: Callback): void {\n    const isExplain = cmd.$explain != null;\n    const readPreference = options.readPreference ?? ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n    if (\n      limit &&\n      (limit < 0 || (limit !== 0 && limit < batchSize) || (limit > 0 && batchSize === 0))\n    ) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions: OpQueryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      secondaryOk: readPreference.secondaryOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new Query(ns.toString(), cmd, queryOptions);\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(\n      this,\n      query,\n      { [kFullResult]: true, ...pluckBSONSerializeOptions(options) },\n      (err, result) => {\n        if (err || !result) return callback(err, result);\n        if (isExplain && result.documents && result.documents[0]) {\n          return callback(undefined, result.documents[0]);\n        }\n\n        callback(undefined, result);\n      }\n    );\n  }\n\n  getMore(\n    ns: MongoDBNamespace,\n    cursorId: Long,\n    options: GetMoreOptions,\n    callback: Callback<Document>\n  ): void {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = maxWireVersion(this);\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\n      const queryOptions = applyCommonQueryOptions(\n        {},\n        Object.assign(options, { ...pluckBSONSerializeOptions(options) })\n      );\n\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\n      });\n\n      return;\n    }\n\n    const getMoreCmd: Document = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      getMoreCmd.comment = options.comment;\n    }\n\n    const commandOptions = Object.assign(\n      {\n        returnFieldSelector: null,\n        documentsReturnedIn: 'nextBatch'\n      },\n      options\n    );\n\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n\n  killCursors(\n    ns: MongoDBNamespace,\n    cursorIds: Long[],\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if (maxWireVersion(this) < 4) {\n      try {\n        write(\n          this,\n          new KillCursor(ns.toString(), cursorIds),\n          { noResponse: true, ...options },\n          callback\n        );\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(\n      ns,\n      { killCursors: ns.collection, cursors: cursorIds },\n      { [kFullResult]: true, ...options },\n      (err, response) => {\n        if (err || !response) return callback(err);\n        if (response.cursorNotFound) {\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\n        }\n\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\n          return callback(\n            // TODO(NODE-3483)\n            new MongoRuntimeError(\n              `invalid killCursors result returned for cursor id ${cursorIds[0]}`\n            )\n          );\n        }\n\n        callback(undefined, response.documents[0]);\n      }\n    );\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  [kAutoEncrypter]?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  override command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\n      );\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nfunction supportsOpMsg(conn: Connection) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\nfunction write(\n  conn: Connection,\n  command: WriteProtocolMessageType,\n  options: CommandOptions,\n  callback: Callback\n) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options ?? {};\n  const operationDescription: OperationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(\n          Connection.COMMAND_FAILED,\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(\n            Connection.COMMAND_FAILED,\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\n          );\n        } else {\n          conn.emit(\n            Connection.COMMAND_SUCCEEDED,\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}