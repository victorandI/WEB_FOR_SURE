{"ast":null,"code":"'use strict';\n\nconst leanPopulateMap = require('./leanPopulateMap');\n\nconst modelSymbol = require('../symbols').modelSymbol;\n\nconst utils = require('../../utils');\n\nmodule.exports = assignRawDocsToIdStructure;\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n    doc = resultDocs[sid]; // If user wants separate copies of same doc, use this option\n\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n\n        doc = utils.clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n\n          if (Array.isArray(_resultOrder) && Array.isArray(doc) && _resultOrder.length === doc.length) {\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function (doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}","map":{"version":3,"names":["leanPopulateMap","require","modelSymbol","utils","module","exports","assignRawDocsToIdStructure","rawIds","resultDocs","resultOrder","options","recursed","newOrder","sorting","sort","length","nullIfNotFound","$nullIfNotFound","doc","sid","id","isMongooseArray","__array","i","len","Array","isArray","push","String","clone","lean","_model","get","set","constructor","hydrate","_doc","_resultOrder","retainNullValues","forEach"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"],"sourcesContent":["'use strict';\n\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\n\nmodule.exports = assignRawDocsToIdStructure;\n\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = utils.clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (Array.isArray(_resultOrder) && Array.isArray(doc) && _resultOrder.length === doc.length) {\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}