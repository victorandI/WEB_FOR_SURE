{"ast":null,"code":"/*!\n * Module dependencies.\n */\n'use strict';\n\nconst MongooseConnection = require('../../connection');\n\nconst STATES = require('../../connectionstate');\n\nconst immediate = require('../../helpers/immediate');\n\nconst setTimeout = require('../../helpers/timers').setTimeout;\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n/**\n * Expose the possible connection states.\n * @api public\n */\n\n\nNativeConnection.STATES = STATES;\n/*!\n * Inherits from Connection.\n */\n\nNativeConnection.prototype.__proto__ = MongooseConnection.prototype;\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function (name, options) {\n  // Return immediately if cached\n  options = options || {};\n\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  } // we have to manually copy all of the attributes...\n\n\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass; // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name; // push onto the otherDbs stack, this is used when state changes\n\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n\n  newConn.otherDbs.push(this); // push onto the relatedDbs cache, this is used when state changes\n\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @param {Function} [fn]\n * @return {Connection} this\n * @api private\n */\n\n\nNativeConnection.prototype.doClose = function (force, fn) {\n  if (this.client == null) {\n    immediate(() => fn());\n    return this;\n  }\n\n  let skipCloseClient = false;\n\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    immediate(() => fn());\n    return this;\n  }\n\n  this.client.close(force, (err, res) => {\n    // Defer because the driver will wait at least 1ms before finishing closing\n    // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n    // If there's queued operations, you may still get some background work\n    // after the callback is called.\n    setTimeout(() => fn(err, res), 1);\n  });\n  return this;\n};\n/*!\n * Module exports.\n */\n\n\nmodule.exports = NativeConnection;","map":{"version":3,"names":["MongooseConnection","require","STATES","immediate","setTimeout","NativeConnection","apply","arguments","_listening","prototype","__proto__","useDb","name","options","useCache","relatedDbs","newConn","constructor","base","collections","models","replica","config","Object","assign","_readyState","_closeCalled","_hasOpened","_parent","host","port","user","pass","_this","client","db","connected","wireup","once","_opts","hasOwnProperty","noListener","onOpen","otherDbs","push","doClose","force","fn","skipCloseClient","close","err","res","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst STATES = require('../../connectionstate');\nconst immediate = require('../../helpers/immediate');\nconst setTimeout = require('../../helpers/timers').setTimeout;\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nNativeConnection.prototype.__proto__ = MongooseConnection.prototype;\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @param {Function} [fn]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = function(force, fn) {\n  if (this.client == null) {\n    immediate(() => fn());\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    immediate(() => fn());\n    return this;\n  }\n\n  this.client.close(force, (err, res) => {\n    // Defer because the driver will wait at least 1ms before finishing closing\n    // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n    // If there's queued operations, you may still get some background work\n    // after the callback is called.\n    setTimeout(() => fn(err, res), 1);\n  });\n  return this;\n};\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}