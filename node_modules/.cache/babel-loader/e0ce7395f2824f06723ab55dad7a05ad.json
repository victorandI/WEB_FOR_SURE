{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\n\nconst CastError = require('../error/cast');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst SchemaDocumentArrayOptions = require('../options/SchemaDocumentArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst discriminator = require('../helpers/model/discriminator');\n\nconst handleIdOption = require('../helpers/schema/handleIdOption');\n\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\n\nconst utils = require('../utils');\n\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\n\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\n\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n\n  EmbeddedDocument.prototype.$basePath = key;\n  ArrayType.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      let arr = fn.call(this);\n\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      } // Leave it up to `cast()` to convert this to a documentarray\n\n\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: this && this.schemaOptions && this.schemaOptions.required || false\n  });\n\n  this.$embeddedSchemaType.cast = function (value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nDocumentArrayPath.schemaName = 'DocumentArray';\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = {\n  castNonArrays: true\n};\n/*!\n * Inherits from ArrayType.\n */\n\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/ArraySubdocument')); // compile an embedded document for this schema\n\n  function EmbeddedDocument(_value, parentArray) {\n    Subdocument.apply(this, arguments);\n\n    if (parentArray == null || parentArray.getArrayParent() == null) {\n      return;\n    }\n\n    this.$session(parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter(); // apply methods\n\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\n\nDocumentArrayPath.prototype.discriminator = function (name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {// Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  const _this = this;\n\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n\n    if (options && options.updateValidator) {\n      return fn();\n    }\n\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    } // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      } // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n\n\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidateSync = function (array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  } // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n\n    if (!doc) {\n      continue;\n    } // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n\n\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.getDefault = function (scope) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  } // lazy load\n\n\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n\n    _subdoc.$init(ret[i]);\n\n    _subdoc.isNew = true; // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({\n  transform: false,\n  virtuals: false\n});\n\nconst initDocumentOptions = Object.freeze({\n  skipId: true,\n  willInit: true\n});\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray')); // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    } // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n\n\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init, prev, options);\n  } // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n\n\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]); // Check if the document has a different schema (re gh-3701)\n\n    if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {\n      const spreadDoc = handleSpreadDoc(rawArray[i], true);\n\n      if (rawArray[i] !== spreadDoc) {\n        rawArray[i] = spreadDoc;\n      } else {\n        rawArray[i] = rawArray[i].toObject({\n          transform: false,\n          // Special case: if different model, but same schema, apply virtuals\n          // re: gh-7898\n          virtuals: rawArray[i].schema === Constructor.schema\n        });\n      }\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      } // Might not have the correct index yet, so ensure it does.\n\n\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]); // if set() is hooked it will have no return value\n          // see gh-746\n\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined, undefined, i); // if set() is hooked it will have no return value\n            // see gh-746\n\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i], value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.applyGetters = function (value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n\n      if (sub === '$') {\n        continue;\n      }\n\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\n\nDocumentArrayPath.defaultOptions = {};\nDocumentArrayPath.set = SchemaType.set;\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;","map":{"version":3,"names":["ArrayType","require","CastError","EventEmitter","SchemaDocumentArrayOptions","SchemaType","discriminator","handleIdOption","handleSpreadDoc","utils","getConstructor","arrayAtomicsSymbol","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","DocumentArrayPath","key","schema","options","schemaOptions","_id","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","parentSchemaType","$embeddedSchemaType","required","cast","value","doc","init","$isMongooseDocumentArrayElement","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","baseClass","_value","parentArray","apply","arguments","getArrayParent","$session","_preCompile","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","getFunctionName","tiedValue","isPOJO","clone","instanceOfSchema","casterConstructor","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","undefined","validateModifiedOnly","$isModified","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","ret","_subdoc","$init","isNew","assign","$__","activePaths","_toObjectOptions","freeze","transform","virtuals","initDocumentOptions","skipId","willInit","prev","selected","subdoc","markModified","skipDocumentArrayCast","arrayPathIndex","rawArray","__array","spreadDoc","toObject","__index","$setIndex","scopePaths","id","deepEqual","set","schematype","validators","slice","requiredValidator","applyGetters","fields","keys","hasKeys","sub","startsWith","substring","defaultOptions","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/schema/documentarray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaDocumentArrayOptions =\n  require('../options/SchemaDocumentArrayOptions');\nconst SchemaType = require('../schematype');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false\n  });\n  this.$embeddedSchemaType.cast = function(value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = { castNonArrays: true };\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/ArraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument(_value, parentArray) {\n    Subdocument.apply(this, arguments);\n    if (parentArray == null || parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function(scope) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: true, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {\n      const spreadDoc = handleSpreadDoc(rawArray[i], true);\n      if (rawArray[i] !== spreadDoc) {\n        rawArray[i] = spreadDoc;\n      } else {\n        rawArray[i] = rawArray[i].toObject({\n          transform: false,\n          // Special case: if different model, but same schema, apply virtuals\n          // re: gh-7898\n          virtuals: rawArray[i].schema === Constructor.schema\n        });\n      }\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nDocumentArrayPath.defaultOptions = {};\n\nDocumentArrayPath.set = SchemaType.set;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}