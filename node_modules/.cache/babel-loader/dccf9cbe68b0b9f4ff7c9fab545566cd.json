{"ast":null,"code":"/*!\n * Module dependencies.\n */\n'use strict';\n\nconst utils = require('./utils'); // eslint-disable-line no-unused-vars\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\n\nconst StateMachine = module.exports = exports = function StateMachine() {};\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\n\nStateMachine.ctor = function () {\n  const states = [...arguments];\n\n  const ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n    let i = states.length,\n        state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = new StateMachine();\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    };\n  });\n  return ctor;\n};\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n/*!\n * ignore\n */\n\n\nStateMachine.prototype.clear = function clear(state) {\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    return Object.keys(_this.states[state]).length;\n  });\n};\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function () {\n    let states = [...arguments];\n    const callback = states.pop();\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function (paths, state) {\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};","map":{"version":3,"names":["utils","require","StateMachine","module","exports","ctor","states","arguments","apply","paths","stateNames","i","length","state","prototype","forEach","path","_changeState","nextState","prevBucket","clear","keys","Object","some","_this","what","Array","call","_iter","iterMethod","callback","pop","reduce","concat","map"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/statemachine.js"],"sourcesContent":["\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst utils = require('./utils'); // eslint-disable-line no-unused-vars\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\nStateMachine.ctor = function() {\n  const states = [...arguments];\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n\n    let i = states.length,\n        state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = new StateMachine();\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    let states = [...arguments];\n    const callback = states.pop();\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}