{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\n\nconst $type = require('./operators/type');\n\nconst MongooseError = require('../error/mongooseError');\n\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst CastError = SchemaType.CastError;\n\nconst Mixed = require('./mixed');\n\nconst arrayDepth = require('../helpers/arrayDepth');\n\nconst cast = require('../cast');\n\nconst isOperator = require('../helpers/query/isOperator');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst castToNumber = require('./operators/helpers').castToNumber;\n\nconst geospatial = require('./operators/geospatial');\n\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    } // support { type: 'String' }\n\n\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      // Leave it up to `cast()` to convert the array\n      return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];\n    };\n\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @api public\n */\n\nSchemaArray.set = SchemaType.set;\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  } // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n\n\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n\n  while (true) {\n    const instance = arr && arr.caster && arr.caster.instance;\n\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n\n    break;\n  }\n\n  let enumArray = arguments;\n\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n\n  if (Array.isArray(ret)) {\n    const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;\n    const len = rawValue.length;\n\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    } // No need to wrap empty arrays\n\n\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      } // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n\n\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substring(0, this.path.lastIndexOf('.')) : null;\n\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n\n        for (i = 0; i < len; i++) {\n          const opts = {}; // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n    const caster = this.caster;\n\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {}; // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this;\n\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n\n  return arr.discriminator(name, schema);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  return schematype;\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n\n    if (v.$elemMatch != null) {\n      return {\n        $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch)\n      };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o)[this.path];\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  } // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n\n\n  const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};\n\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$not = handle.$regex = SchemaArray.prototype.castForQuery; // `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\n\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","ref","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$embeddedSchemaType","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","arr","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","$populated","ret","rawValue","isMongooseArray","__array","len","length","i","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","valueDepth","min","max","containsNonArrayItem","prev","l","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substring","lastIndexOf","_arrayPath","opts","arrayPathIndex","_arrayParentPath","applySetters","e","kind","inspect","markModified","_castForPopulate","$toObject","toObject","discriminator","assign","schematype","validators","slice","requiredValidator","undefined","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$not","$regex","$nin","$in","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  if (Array.isArray(ret)) {\n    const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;\n    const len = rawValue.length;\n    for (let i = 0; i < len; ++i) {\n      rawValue[i] = this.caster.applyGetters(rawValue[i], scope);\n    }\n  }\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o)[this.path];\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$not =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}