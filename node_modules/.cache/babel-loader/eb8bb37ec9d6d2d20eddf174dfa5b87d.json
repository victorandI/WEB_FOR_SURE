{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst InternalCache = require('./internal');\n\nconst MongooseError = require('./error/index');\n\nconst MixedSchema = require('./schema/mixed');\n\nconst ObjectExpectedError = require('./error/objectExpected');\n\nconst ObjectParameterError = require('./error/objectParameter');\n\nconst ParallelValidateError = require('./error/parallelValidate');\n\nconst Schema = require('./schema');\n\nconst StrictModeError = require('./error/strict');\n\nconst ValidationError = require('./error/validation');\n\nconst ValidatorError = require('./error/validator');\n\nconst VirtualType = require('./virtualtype');\n\nconst $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');\n\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\n\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\n\nconst compile = require('./helpers/document/compile').compile;\n\nconst defineKey = require('./helpers/document/compile').defineKey;\n\nconst flatten = require('./helpers/common').flatten;\n\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\n\nconst get = require('./helpers/get');\n\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\n\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\n\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\n\nconst immediate = require('./helpers/immediate');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst isExclusive = require('./helpers/projection/isExclusive');\n\nconst inspect = require('util').inspect;\n\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\n\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\n\nconst mpath = require('mpath');\n\nconst queryhelpers = require('./queryhelpers');\n\nconst utils = require('./utils');\n\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\n\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\n\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\n\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\n\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\n\nconst getSymbol = require('./helpers/symbols').getSymbol;\n\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\n\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\n\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\n\nconst parentPaths = require('./helpers/path/parentPaths');\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\nconst specialProperties = utils.specialProperties;\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n\n  options = Object.assign({}, options); // Support `browserDocument.js` syntax\n\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;\n\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n  this.$isNew = 'isNew' in options ? options.isNew : true;\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n\n    if (fields != null) {\n      this.$__.selected = fields;\n    }\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null; // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n    this.$__.fields = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false); // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n\n    if (defaults) {\n      $__applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  } // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n\n\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    $__applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n\n    const keys = Object.keys(this._doc);\n    keys.forEach(function (key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({\n          prop: key,\n          subprops: null,\n          prototype: _this\n        });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function () {\n    return this.$isNew;\n  },\n  set: function (value) {\n    this.$isNew = value;\n  }\n});\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function () {\n    return this.$errors;\n  },\n  set: function (value) {\n    this.$errors = value;\n  }\n});\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\n\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    // Delay creating emitter until necessary because emitters take up a lot of memory,\n    // especially for subdocuments.\n    if (!this.$__.emitter) {\n      if (emitterFn === 'emit') {\n        return;\n      }\n\n      this.$__.emitter = new EventEmitter();\n      this.$__.emitter.setMaxListeners(0);\n    }\n\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n\n  Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n});\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__schema;\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function () {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n\n    return this.$__.locals;\n  },\n  set: function (v) {\n    this.$__.locals = v;\n  }\n});\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$isNew;\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function () {\n    return this.$__.op || null;\n  },\n  set: function (value) {\n    this.$__.op = value;\n  }\n});\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n\n        if (curPath in fields || hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath]) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  flattenObjectWithDottedPaths(val);\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n  const paths = Object.keys(this.$__schema.paths). // Don't build up any paths that are underneath a map, we don't know\n  // what the keys will be\n  filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      } // support excluding intermediary levels\n\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n/*!\n * Converts to POJO when you use the document for querying\n */\n\n\nDocument.prototype.toBSON = function () {\n  return this.toObject(internalToObjectOptions);\n};\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.init = function (doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\nDocument.prototype.$init = function () {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\nDocument.prototype.$__init = function (doc, opts) {\n  this.$isNew = false;\n  opts = opts || {}; // handle docs with populated paths\n  // If doc._id is not null or undefined\n\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n\n        child.$__.parent = this;\n      }\n\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n  markArraySubdocsPopulated(this, opts.populated);\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.fields ? $__hasIncludedChildren(this.$__.fields) : null;\n  $__applyDefaults(this, this.$__.fields, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n  return this;\n};\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schemaType = docSchema.path(path); // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            doc[i] = schemaType.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      } // mark as hydrated\n\n\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.update = function update() {\n  const args = [...arguments];\n  args.unshift({\n    _id: this._id\n  });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({\n    _id: this._id\n  }, doc, options);\n  query.pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query.post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' + 'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    } // Explicitly skip version key\n\n\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n  const strict = options && 'strict' in options ? options.strict : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n    const len = keys.length; // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n\n      if (val) {\n        this.$set(val, {});\n      }\n\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key]; // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n\n      if (type === true && !prefix && valForKey != null && pathtype === 'nested' && this._doc[key] != null) {\n        delete this._doc[key]; // Make sure we set `{}` back even if we minimize re: gh-8565\n\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: true\n        });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, {\n          _skipMinimizeTopLevel: false\n        });\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        $applyDefaultsToNested(path[key], prefix + key, this);\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, {\n          _skipMarkModified: true\n        }));\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 && this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, {\n            typeOnly: true\n          });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          const p = path[key];\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key, path[key].toObject({\n            transform: false\n          }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    } // Ensure all properties are in correct order\n\n\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = undefined);\n    }\n\n    this._doc = Object.assign(orderedDoc, this._doc);\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, {\n      typeOnly: true\n    });\n  } // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n\n\n  val = handleSpreadDoc(val); // if this doc is being constructed we should not trigger getters\n\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n\n    if (constructing) {\n      return void 0;\n    }\n\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n        const keys = Object.keys(initialVal || {});\n\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n      this.$__setValue(path, {});\n\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n\n      return this;\n    }\n\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.'); // Might need to change path for top-level alias\n\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.'); // If path is underneath a virtual, bypass everything and just set it.\n\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  } // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n\n\n  let cur = this._doc;\n  let curPath = '';\n\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n\n    if (!cur) {\n      this.$set(curPath, {}); // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark; // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      if (this.$get(subpath, null, {\n        getters: false\n      }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n\n    return this;\n  } // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n\n\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({\n        virtuals: false,\n        transform: false\n      });\n    }\n\n    const keys = Object.keys(val);\n\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n\n      if (!(val instanceof Document)) {\n        return false;\n      }\n\n      const model = val.constructor; // Check ref\n\n      const ref = schema.options.ref;\n\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      } // Check refPath\n\n\n      const refPath = schema.options.refPath;\n\n      if (refPath == null) {\n        return false;\n      }\n\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, {\n        [populateModelSymbol]: val.constructor\n      });\n      val.$__.wasPopulated = {\n        value: unpopulatedValue\n      };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n\n    if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = {\n        [populateModelSymbol]: val[0].constructor\n      };\n      this.$populated(path, val.map(function (v) {\n        return v._id;\n      }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = {\n          value: doc._id\n        };\n      }\n\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal, options);\n    }\n\n    if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath, val.map(v => v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);\n      }\n\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n\n      if (e.$originalErrorPath) {\n        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    }\n\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n\n      if (savedState != null) {\n        const firstDot = savedStatePath.indexOf('.');\n        const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n\n        if (!savedState.hasOwnProperty(topLevelPath)) {\n          savedState[topLevelPath] = utils.clone(doc.$__getValue(topLevelPath));\n        }\n      }\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n\n    const modelName = el.constructor.modelName;\n\n    if (modelName == null) {\n      return false;\n    }\n\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Sets the value of a path, or many paths.\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.set = Document.prototype.$set;\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n\n  if (this.$isNew) {\n    return true;\n  } // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n\n\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  } // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n\n\n  if (this.$populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n\n  return false;\n};\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__set = function (pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n  if (shouldModify) {\n    this.markModified(pathToMark); // handle directly setting arrays (gh-1126)\n\n    MongooseArray || (MongooseArray = require('./types/array'));\n\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val); // Update embedded document parent references (gh-5189)\n\n\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function (item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => {\n        doc.isNew = false;\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\n\nDocument.prototype.$__getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\n\nDocument.prototype.$__setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n/**\n * Returns the value of a path.\n *\n * #### Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\n\nDocument.prototype.get = function (path, type, options) {\n  let adhoc;\n  options = options || {};\n\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  let schema = this.$__path(path);\n\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  } // Might need to change path for top-level alias\n\n\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], {\n        getters: false\n      });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, {\n      path: path\n    });\n  }\n\n  return obj;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function (path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n\n  return this.$__schema.path(path);\n};\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\n\nDocument.prototype.markModified = function (path, scope) {\n  this.$__.activePaths.modify(path);\n\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.directModifiedPaths = function () {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * #### Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\n\nDocument.prototype.$isEmpty = function (path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n\n    if (v == null) {\n      return true;\n    }\n\n    if (typeof v !== 'object') {\n      return false;\n    }\n\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.modifiedPaths = function (options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const result = new Set();\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n\n      const len = cur.length;\n\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n\n          if (!result.has(subPath)) {\n            result.add(subPath);\n\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function (paths, modifiedPaths) {\n  if (paths) {\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\n    if (directModifiedPaths.length === 0) {\n      return false;\n    }\n\n    if (!Array.isArray(paths)) {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype.$isModified = Document.prototype.isModified;\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n/**\n * Checks if a path is set to its default.\n *\n * #### Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.default.hasOwnProperty(path);\n  }\n\n  let paths = path;\n\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));\n};\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$isDeleted = function (val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isDirectModified = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.modify.hasOwnProperty(path);\n  }\n\n  let paths = path;\n\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));\n};\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isInit = function (path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.init.hasOwnProperty(path);\n  }\n\n  let paths = path;\n\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));\n};\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (!path) {\n    return false;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * #### Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\n\nDocument.prototype.validate = function (pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {// Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack\n    });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, error => {\n      this.$op = null;\n      this.$__.validating = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\nDocument.prototype.$validate = Document.prototype.validate;\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.states.require);\n  let i = 0;\n  const len = requiredFields.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc); // only validate required fields when necessary\n\n\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function (path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n\n    return true;\n  }));\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n\n  function addToPaths(p) {\n    paths.add(p);\n  }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();\n\n      for (const p of paths) {\n        if (p === null || p.startsWith(fullPathToSubdoc + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) && !doc.isDirectModified(fullPathToSubdoc) && !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n        skipSchemaValidators[fullPathToSubdoc] = true;\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType) {\n      continue;\n    } // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n\n\n    if (!_pathType.caster && _pathType.validators.length === 0) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n    !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n    _pathType.validators.length === 0 && // and arrays with top-level validators\n    _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  } // from here on we're not removing items from paths\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children\n    // are not required. `getPositionalPathType()` may be slow, so avoid\n    // it unless we have a case of #6364\n    !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {\n      continue;\n    } // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n\n\n    if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n    !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n    _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = {\n    skipArrays: true\n  };\n\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    if (val == null) {\n      continue;\n    }\n\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__validate = function (pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  const pathsToSkip = options && options.pathsToSkip || null;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  }; // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.$isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  if (paths.length === 0) {\n    return immediate(function () {\n      const error = _complete();\n\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n          error: error\n        }, function (error) {\n          callback(error);\n        });\n      }\n\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n    immediate(function () {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      } // If user marked as invalid or there was a cast error, don't validate\n\n\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      } // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n\n\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path); // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n\n\n      let pop;\n\n      if (pop = _this.$populated(path)) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n      schemaType.doValidate(val, function (err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;\n\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n\n          _this.invalidate(path, err, undefined, true);\n        }\n\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], {\n        error: error\n      }, function (error) {\n        callback(error);\n      });\n    }\n\n    callback(null, _this);\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n\n  const parentPaths = new Map([]);\n\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n\n    const pieces = path.split('.');\n    let cur = pieces[0];\n\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n\n  return ret;\n}\n/*!\n * ignore\n */\n\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\n\nDocument.prototype.validateSync = function (pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  } // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.$isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n\n    if (!p) {\n      continue;\n    }\n\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n\n    if (err) {\n      const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;\n\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n\n  _this.$emit('validate', _this);\n\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key); // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|Array<String>} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\n\nDocument.prototype.$isValid = function (path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this; // Skip for subdocuments\n\n\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      subdoc.$__reset();\n\n      if (subdoc.$isDocumentArrayElement) {\n        if (!resetArrays.has(subdoc.parentArray())) {\n          const array = subdoc.parentArray(); // Mark path to array as init for gh-6818\n\n          this.$__.activePaths.init(fullPathWithIndexes.replace(/\\.\\d+$/, '').slice(-subdoc.$basePath - 1));\n          array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n          array[arrayAtomicsSymbol] = {};\n          resetArrays.add(array);\n        }\n      } else {\n        if (subdoc.$parent() === this) {\n          this.$__.activePaths.init(subdoc.$basePath);\n        } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          subdoc.$parent().$__reset();\n        }\n      }\n    }\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  } // clear atomics\n\n\n  this.$__dirty().forEach(function (dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors; // Clear 'dirty' cache\n\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__dirty = function () {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }); // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n  const allPaths = new Map(all.filter(el => el != null).map(el => [el.path, el.value])); // Ignore \"foo.a\" if \"foo\" is dirty already.\n\n  const minimal = [];\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n    const array = parentPaths(item.path);\n\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__setSchema = function (schema) {\n  compile(schema.tree, this, undefined, schema.options); // Apply default getters if virtual doesn't have any (gh-6262)\n\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray')); // validate all document arrays.\n\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.$__getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n/**\n * Get all subdocs (by bfs)\n *\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function (seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function (seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n\n        seed = Object.keys(doc._doc).reduce(function (seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n\n    return seed;\n  }\n\n  const subDocs = [];\n\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n/*!\n * Runs queued functions\n */\n\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$toObject = function (options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor && this.constructor.base && this.constructor.base.options && get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {}; // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {})); // If options do not exist or is not an object, set it to empty object\n\n  options = utils.isPOJO(options) ? { ...options\n  } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options\n  };\n\n  let _minimize;\n\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  } // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n\n\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    _seen: options && options._seen || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate || options._parentOptions && options._parentOptions.depopulate || false; // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  } // merge default options with input options.\n\n\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false; // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n\n  const originalTransform = options.transform;\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform; // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || schemaOptions.toObject && transform) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * #### Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary https://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys ? obj : undefined;\n}\n/*!\n * Applies virtuals properties to `json`.\n */\n\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean' ? toObjectOptions.aliases : true;\n  let virtualsToApply = null;\n\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    } // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n\n\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    } // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n\n\n    assignPath = path;\n\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n\n      assignPath = path.substring(options.path.length + 1);\n    }\n\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n\n    if (v === void 0) {\n      continue;\n    }\n\n    const plen = parts.length;\n    cur = json;\n\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n\n      cur = v;\n    }\n  }\n\n  return json;\n}\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n\n      if (val === undefined) {\n        continue;\n      }\n\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n\n      if (val === undefined) {\n        continue;\n      }\n\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\n\nDocument.prototype.ownerDocument = function () {\n  return this;\n};\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.parent = function () {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n\n  return this;\n};\n/**\n * Alias for `parent()`. If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$parent = Document.prototype.parent;\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function (options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toString = function () {\n  const ret = this.inspect();\n\n  if (typeof ret === 'string') {\n    return ret;\n  }\n\n  return inspect(ret);\n};\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // not populated\n *\n *     await doc.populate('author fans', '-email');\n *     doc.author.email // not populated\n *     doc.fans[0].email // not populated\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model.populate\n * @memberOf Document\n * @instance\n * @return {Promise|null}\n * @api public\n */\n\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = [...arguments];\n  let fn;\n\n  if (args.length !== 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    } // use hash to remove duplicate paths\n\n\n    const res = utils.populate.apply(null, args);\n\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function (populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  } // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n\n\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n  return topLevelModel.populate(this, paths, fn);\n};\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n\n  let result = [];\n\n  for (const key of keys) {\n    const value = this.$get(key);\n\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n\n  return result;\n};\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    if (typeof path !== 'string') {\n      return undefined;\n    } // Map paths can be populated with either `path.$*` or just `path`\n\n\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n\n    if (v) {\n      return val === true ? v : v.value;\n    }\n\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  }; // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n\n  const pieces = path.split('.');\n\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options); // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n\n      break;\n    }\n  }\n\n  return val;\n};\n\nDocument.prototype.$populated = Document.prototype.populated;\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function (path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n\n      if (!populatedIds) {\n        continue;\n      }\n\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n\n  return this;\n};\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.getChanges = function () {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n/*!\n * Module exports.\n */\n\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"names":["EventEmitter","require","InternalCache","MongooseError","MixedSchema","ObjectExpectedError","ObjectParameterError","ParallelValidateError","Schema","StrictModeError","ValidationError","ValidatorError","VirtualType","$__hasIncludedChildren","promiseOrCallback","cleanModifiedSubpaths","compile","defineKey","flatten","flattenObjectWithDottedPaths","get","getEmbeddedDiscriminatorPath","getKeysInSchemaOrder","handleSpreadDoc","immediate","isDefiningProjection","isExclusive","inspect","internalToObjectOptions","markArraySubdocsPopulated","mpath","queryhelpers","utils","isPromise","clone","deepEqual","isMongooseObject","arrayAtomicsBackupSymbol","arrayAtomicsSymbol","documentArrayParent","documentIsModified","documentModifiedPaths","documentSchemaSymbol","getSymbol","populateModelSymbol","scopeSymbol","schemaMixedSymbol","parentPaths","DocumentArray","MongooseArray","Embedded","specialProperties","Document","obj","fields","skipId","options","Object","assign","$__schema","_schema","isObject","instanceOfSchema","$__setSchema","arguments","$__","$isNew","isNew","priorDoc","defaults","undefined","schema","strictMode","strict","selected","requiredPaths","path","activePaths","exclude","isPOJO","hasIncludedChildren","_doc","$__buildDoc","$__applyDefaults","$__original_set","$set","willInit","skipDefaults","_this","keys","forEach","key","tree","methods","virtuals","startsWith","prop","subprops","prototype","applyQueue","defineProperty","set","value","$errors","each","emitterFn","emitter","setMaxListeners","apply","constructor","i","configurable","enumerable","locals","v","writable","id","errors","op","doc","isBeforeSetters","pathsToSkip","paths","plen","length","def","curPath","p","type","splitPath","len","included","doc_","j","piece","hasSubpaths","$isSingleNested","$isMongooseDocumentArray","defaultValue","$runBeforeSetters","getDefault","err","invalidate","default","$applyDefaultsToNested","val","pathPieces","indexOf","split","pieces","slice","cur","filter","includes","ii","last","toBSON","toObject","init","opts","fn","$__init","$init","_id","populated","String","item","isVirtual","$populated","getValue","_docs","_childDocs","child","parent","$emit","emit","self","prefix","schemaType","index","docSchema","_init","$isRootDiscriminator","$__isSelected","hasOwnProperty","_castNullish","wasPopulated","cast","e","message","reason","$isModified","update","args","unshift","query","$session","session","updateOne","callback","pre","cb","_middleware","execPre","post","execPost","exec","replaceOne","hasEnded","$isSubdocument","subdocs","$getAllSubdocs","overwrite","Array","from","Set","concat","versionKey","discriminatorKey","merge","adhoc","constructing","adhocs","pathtype","adhocPaths","interpretAsType","$__isNested","_skipMinimizeTopLevel","pathName","pathType","valForKey","isNonBuiltinObject","_skipMarkModified","$get","typeOnly","transform","orderedDoc","orderedKeys","priorVal","$__getValue","CastError","hasInitialVal","savedState","initialVal","$__setValue","unmarkModified","markModified","parts","aliases","mixed","subpath","join","virtualpath","applySetters","$__path","pathToMark","getters","$__set","$isMongooseArray","_markValidSubpaths","shouldSet","refMatches","model","ref","modelName","baseModelName","refPath","didPopulate","unpopulatedValue","popOpts","typeKey","isArray","_isManuallyPopulatedArray","map","singleNestedPaths","populatedPaths","populatedPath","_checkImmutableSubpaths","$markValid","isImmutableError","$originalErrorPath","instance","savedStatePath","ownerDocument","fullPath","firstDot","topLevelPath","isDirectModified","el","$__shouldModify","states","shouldModify","isMongooseArray","_registerAtomic","isMongooseDocumentArray","__parentArray","l","next","has","Map","setValue","virtual","applyGetters","nested","applyVirtuals","adhocType","scope","modify","pathsToScopes","$__pathsToScopes","$ignore","ignore","directModifiedPaths","$isEmpty","isEmptyOptions","minimize","_isEmpty","modifiedPaths","result","pLen","add","includeChildren","subPath","modified","iii","iiiLen","isModified","isModifiedChild","some","mod","$isDefault","$isDeleted","isDeleted","isInit","isSelected","inclusive","pathDot","isDirectSelected","validate","pathsToValidate","parallelValidate","$op","validating","parentStack","conflictStack","stack","isOnePathOnly","$__validate","error","events","$validate","_evaluateRequiredFunctions","requiredFields","originalRequiredValue","cachedRequired","call","_getPathsToValidate","skipSchemaValidators","addToPaths","subdoc","$basePath","fullPathToSubdoc","$__fullPathWithIndexes","delete","_pathType","caster","validators","$embeddedSchemaType","schemaOptions","required","_pushNestedArrayPaths","numElements","flattenOptions","skipArrays","pathToCheck","_v","flat","$isSchemaMap","hasValidateModifiedOnlyOption","shouldValidateModifiedOnly","validateModifiedOnly","_complete","validationError","errPath","pathDetails","_handlePathsToValidate","_handlePathsToSkip","s","hooks","validated","total","validatePath","complete","$isValid","pop","doValidateOptions","doValidate","isSubdoc","$isArraySubdocument","_pathsToValidate","ret","push","validateSync","doValidateSync","kind","addError","schematype","$immutableSetter","oldVal","$__reset","reset","$parent","resetArrays","fullPathWithIndexes","isParentInit","$isDocumentArrayElement","parentArray","array","replace","$__dirty","dirt","backup","clear","$__undoReset","all","allPaths","minimal","top","hasAtomics","_applyDefaultGetters","$__getArrayPathsToValidate","bind","reduce","seed","docReducer","isNested","_docReduce","subDocs","q","callQueue","pair","$__handleReject","handleReject","$listeners","listeners","$toObject","json","defaultOptions","flattenDecimals","baseOptions","base","_calledWithOptions","_minimize","flattenMaps","cloneOptions","_isNested","_seen","hasUserDefinedProperty","depopulate","_parentOptions","_skipSingleNestedGetters","gettersOptions","originalTransform","applySchemaTypeTransforms","useProjection","omitDeselectedFields","toJSON","xformed","hasKeys","toObjectOptions","numPaths","assignPath","virtualsToApply","substring","branch","part","transformedValue","throwErrorIfPromise","vals","Error","applyPaths","custom","toString","equals","tid","docid","populate","res","populateOptions","object","topLevelModel","nestedPath","_localModel","$getPopulatedDocs","_path","endsWith","rest","populatedIds","virtualKeys","$$populatedVirtuals","virtualKey","singlePath","$__fullPath","getChanges","delta","$__delta","changes","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/document.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst VirtualType = require('./virtualtype');\nconst $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst flattenObjectWithDottedPaths = require('./helpers/path/flattenObjectWithDottedPaths');\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst immediate = require('./helpers/immediate');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\nconst parentPaths = require('./helpers/path/parentPaths');\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n  this.$isNew = 'isNew' in options ? options.isNew : true;\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    if (fields != null) {\n      this.$__.selected = fields;\n    }\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n    this.$__.fields = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      $__applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    $__applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$isNew;\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n        if (curPath in fields || (hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  flattenObjectWithDottedPaths(val);\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.fields ?\n    $__hasIncludedChildren(this.$__.fields) :\n    null;\n  $__applyDefaults(this, this.$__.fields, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n\n  return this;\n};\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            doc[i] = schemaType.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  query.pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query.post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = options && 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix + key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n        // Make sure we set `{}` back even if we minimize re: gh-8565\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\n      } else {\n        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441\n        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        $applyDefaultsToNested(path[key], prefix + key, this);\n        this.$set(prefix + key, path[key], constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && path[key] === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          const p = path[key];\n          this.$set(prefix + key, p, constructing, options);\n        } else if (pathtype === 'nested' && path[key] instanceof Document) {\n          this.$set(prefix + key,\n            path[key].toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, path[key]);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (path[key] !== void 0) {\n        this.$set(prefix + key, path[key], constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, options);\n      }\n      if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal, options);\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      if (savedState != null) {\n        const firstDot = savedStatePath.indexOf('.');\n        const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n        if (!savedState.hasOwnProperty(topLevelPath)) {\n          savedState[topLevelPath] = utils.clone(doc.$__getValue(topLevelPath));\n        }\n      }\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.$__schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => { doc.isNew = false; });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    return schema.applyGetters(void 0, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * #### Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    if (directModifiedPaths.length === 0) {\n      return false;\n    }\n\n    if (!Array.isArray(paths)) {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.default.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.modify.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.states.init.hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|Array<String>} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * #### Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      callback = null;\n      pathsToValidate = null;\n    } else if (typeof arguments[0] === 'function') {\n      callback = arguments[0];\n      options = null;\n      pathsToValidate = null;\n    }\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.states.require);\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();\n\n      for (const p of paths) {\n        if (p === null || p.startsWith(fullPathToSubdoc + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n\n        skipSchemaValidators[fullPathToSubdoc] = true;\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (pathsToSkip) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n            schemaType.$isArraySubdocument ||\n            schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = paths.filter(p => !pathsToSkip.has(p));\n  return paths;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|Array<String>} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      subdoc.$__reset();\n      if (subdoc.$isDocumentArrayElement) {\n        if (!resetArrays.has(subdoc.parentArray())) {\n          const array = subdoc.parentArray();\n          // Mark path to array as init for gh-6818\n          this.$__.activePaths.init(fullPathWithIndexes.replace(/\\.\\d+$/, '').slice(-subdoc.$basePath - 1));\n          array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n          array[arrayAtomicsSymbol] = {};\n\n          resetArrays.add(array);\n        }\n      } else {\n        if (subdoc.$parent() === this) {\n          this.$__.activePaths.init(subdoc.$basePath);\n        } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          subdoc.$parent().$__reset();\n        }\n      }\n    }\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/DocumentArray'));\n  Embedded = Embedded || require('./types/ArraySubdocument');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * #### Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary https://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  }\n  else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for `parent()`. If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // not populated\n *\n *     await doc.populate('author fans', '-email');\n *     doc.author.email // not populated\n *     doc.fans[0].email // not populated\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model.populate\n * @memberOf Document\n * @instance\n * @return {Promise|null}\n * @api public\n */\n\nDocument.prototype.populate = function populate() {\n  const pop = {};\n  const args = [...arguments];\n  let fn;\n\n  if (args.length !== 0) {\n    if (typeof args[args.length - 1] === 'function') {\n      fn = args.pop();\n    }\n\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths, fn);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"],"mappings":"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AAO,CAACmL,SAAR,GAAoBmO,iBAApB;EACD;;EAED,IAAI,OAAOnO,SAAP,KAAqB,UAAzB,EAAqC;IACnC,MAAMwO,OAAO,GAAGxO,SAAS,CAAC,IAAD,EAAOqK,GAAP,EAAYxV,OAAZ,CAAzB;;IACA,IAAI,OAAO2Z,OAAP,KAAmB,WAAvB,EAAoC;MAClCnE,GAAG,GAAGmE,OAAN;IACD;EACF;;EAED,OAAOnE,GAAP;AACD,CArID;AAuIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA5V,QAAQ,CAAC8C,SAAT,CAAmB2D,QAAnB,GAA8B,UAASrG,OAAT,EAAkB;EAC9C,OAAO,KAAKqY,SAAL,CAAerY,OAAf,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASmQ,QAAT,CAAkBtQ,GAAlB,EAAuB;EACrB,MAAMoC,IAAI,GAAGhC,MAAM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"},"metadata":{},"sourceType":"script"}