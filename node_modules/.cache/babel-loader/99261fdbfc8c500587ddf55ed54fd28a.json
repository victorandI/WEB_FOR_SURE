{"ast":null,"code":"'use strict';\n\nconst Mixed = require('../../schema/mixed');\n\nconst defineKey = require('../document/compile').defineKey;\n\nconst get = require('../get');\n\nconst utils = require('../../utils');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name + '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base, 'options.applyPluginsToDiscriminators', false); // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  }\n\n  const key = model.schema.options.discriminatorKey;\n  const existingPath = model.schema.path(key);\n\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name + '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n\n  if (typeof tiedValue === 'string' && tiedValue.length || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n\n    if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    } // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n\n\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n\n        if (schema.paths[cur] instanceof Mixed || schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    utils.merge(schema, baseSchema, {\n      isDiscriminatorSchemaMerge: true,\n      omit: {\n        discriminators: true,\n        base: true,\n        _applyDiscriminators: true\n      },\n      omitNested: conflictingPaths.reduce((cur, path) => {\n        cur['tree.' + path] = true;\n        return cur;\n      }, {})\n    }); // Clean up conflicting paths _after_ merging re: gh-6076\n\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    } // Rebuild schema models because schemas may have been merged re: #7884\n\n\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function (newName) {\n        if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {\n          return value;\n        }\n\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n    schema.discriminatorMapping = {\n      key: key,\n      value: value,\n      isRoot: false\n    };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Special case: compiling a model sets `pluralization = true` by default. Avoid throwing an error\n        // for that case. See gh-9238\n        if (_key === 'pluralization' && schema.options[_key] == true && baseSchema.options[_key] == null) {\n          continue;\n        }\n\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key + ' (can only modify ' + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') + ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  } // merges base schema into new discriminator schema and sets new type field.\n\n\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {\n      key: key,\n      value: null,\n      isRoot: true\n    };\n  }\n\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};","map":{"version":3,"names":["Mixed","require","defineKey","get","utils","CUSTOMIZABLE_DISCRIMINATOR_OPTIONS","toJSON","toObject","_id","id","module","exports","discriminator","model","name","schema","tiedValue","applyPlugins","instanceOfSchema","Error","discriminatorMapping","isRoot","applyPluginsToDiscriminators","base","_applyPlugins","skipTopLevel","key","options","discriminatorKey","existingPath","path","hasUserDefinedProperty","select","$skipDiscriminatorCheck","baseSchemaAddition","default","typeKey","String","add","prop","prototype","value","length","merge","baseSchema","_baseSchema","paths","auto","remove","baseSchemaPaths","Object","keys","conflictingPaths","nested","push","indexOf","sp","split","slice","cur","piece","singleNestedPaths","isDiscriminatorSchemaMerge","omit","discriminators","_applyDiscriminators","omitNested","reduce","conflictingPath","childSchemas","forEach","obj","$__setSchema","set","newName","Array","isArray","deepEqual","collection","_key","join","clone","s","hooks","plugins","call","callQueue","concat","_requiredpaths","overwriteModels"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/model/discriminator.js"],"sourcesContent":["'use strict';\n\nconst Mixed = require('../../schema/mixed');\nconst defineKey = require('../document/compile').defineKey;\nconst get = require('../get');\nconst utils = require('../../utils');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false);\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    utils.merge(schema, baseSchema, {\n      isDiscriminatorSchemaMerge: true,\n      omit: { discriminators: true, base: true, _applyDiscriminators: true },\n      omitNested: conflictingPaths.reduce((cur, path) => {\n        cur['tree.' + path] = true;\n        return cur;\n      }, {})\n    });\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Special case: compiling a model sets `pluralization = true` by default. Avoid throwing an error\n        // for that case. See gh-9238\n        if (_key === 'pluralization' && schema.options[_key] == true && baseSchema.options[_key] == null) {\n          continue;\n        }\n\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n\n    schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}