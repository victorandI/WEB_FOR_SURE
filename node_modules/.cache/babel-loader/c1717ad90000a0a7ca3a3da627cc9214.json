{"ast":null,"code":"/*!\n * Module dependencies.\n */\n'use strict';\n\nconst Readable = require('stream').Readable;\n\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\n\nconst eachAsync = require('../helpers/cursor/eachAsync');\n\nconst helpers = require('../queryhelpers');\n\nconst immediate = require('../helpers/immediate');\n\nconst util = require('util');\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](/docs/api.html#query_Query-cursor) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\n\nfunction QueryCursor(query, options) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, {\n    autoDestroy: true,\n    objectMode: true\n  });\n  this.cursor = null;\n  this.query = query;\n\n  const _this = this;\n\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = options || {};\n  model.hooks.execPre('find', query, err => {\n    if (err != null) {\n      _this._markError(err);\n\n      _this.listeners('error').length > 0 && _this.emit('error', err);\n      return;\n    }\n\n    this._transforms = this._transforms.concat(query._transforms.slice());\n\n    if (this.options.transform) {\n      this._transforms.push(options.transform);\n    } // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n\n\n    if (this.options.batchSize) {\n      this.options.cursor = options.cursor || {};\n      this.options.cursor.batchSize = options.batchSize; // Max out the number of documents we'll populate in parallel at 5000.\n\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n\n    model.collection.find(query._conditions, this.options, (err, cursor) => {\n      if (err != null) {\n        _this._markError(err);\n\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n        return;\n      }\n\n      if (_this._error) {\n        cursor.close(function () {});\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n      }\n\n      _this.cursor = cursor;\n\n      _this.emit('cursor', cursor);\n    });\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n/*!\n * Necessary to satisfy the Readable API\n */\n\nQueryCursor.prototype._read = function () {\n  const _this = this;\n\n  _next(this, function (error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n\n    if (!doc) {\n      _this.push(null);\n\n      _this.cursor.close(function (error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n\n      return;\n    }\n\n    _this.push(doc);\n  });\n};\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @api public\n * @method map\n */\n\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function (fn) {\n    this._transforms.push(fn);\n\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n/*!\n * Marks this cursor as errored\n */\n\nQueryCursor.prototype._markError = function (error) {\n  this._error = error;\n  return this;\n};\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close https://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\n\nQueryCursor.prototype.close = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n\n      this.emit('close');\n      cb(null);\n    });\n  }, this.model.events);\n};\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\n\nQueryCursor.prototype.next = function (callback) {\n  return promiseOrCallback(callback, cb => {\n    _next(this, function (error, doc) {\n      if (error) {\n        return cb(error);\n      }\n\n      cb(null, doc);\n    });\n  }, this.model.events);\n};\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\n\nQueryCursor.prototype.eachAsync = function (fn, opts, callback) {\n  const _this = this;\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  return eachAsync(function (cb) {\n    return _next(_this, cb);\n  }, fn, opts, callback);\n};\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\n\nQueryCursor.prototype.options;\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function (flag, value) {\n  const _this = this;\n\n  _waitForCursor(this, function () {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nQueryCursor.prototype.transformNull = function (val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n/*!\n * ignore\n */\n\n\nQueryCursor.prototype._transformForAsyncIterator = function () {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n\n  return this;\n};\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf Query\n * @instance\n * @api public\n */\n\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function () {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n/*!\n * ignore\n */\n\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? {\n    done: true\n  } : {\n    value: doc,\n    done: false\n  };\n}\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n\n  if (ctx._transforms.length) {\n    callback = function (err, doc) {\n      if (err || doc === null && !ctx._mongooseOptions.transformNull) {\n        return cb(err, doc);\n      }\n\n      cb(err, ctx._transforms.reduce(function (doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function () {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        return ctx.cursor.next(_onNext.bind({\n          ctx,\n          callback\n        }));\n      }\n    } else {\n      return ctx.cursor.next(function (error, doc) {\n        if (error) {\n          return callback(error);\n        }\n\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        if (!ctx.query._mongooseOptions.populate) {\n          return _nextDoc(ctx, doc, null, callback);\n        }\n\n        ctx.query.model.populate(doc, ctx._pop, function (err, doc) {\n          if (err) {\n            return callback(err);\n          }\n\n          return _nextDoc(ctx, doc, ctx._pop, callback);\n        });\n      });\n    }\n  } else {\n    ctx.once('error', cb);\n    ctx.once('cursor', function (cursor) {\n      ctx.removeListener('error', cb);\n\n      if (cursor == null) {\n        return;\n      }\n\n      _next(ctx, cb);\n    });\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));\n    }\n\n    this.ctx.cursor.next(_onNext.bind(this));\n  } else {\n    _populateBatch.call(this);\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n\n  const _this = this;\n\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function (err) {\n    if (err) {\n      return _this.callback(err);\n    }\n\n    _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);\n  });\n}\n/*!\n * ignore\n */\n\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n\n      callback(null, doc);\n    });\n  }\n\n  const {\n    model,\n    _fields,\n    _userProvidedFields,\n    options\n  } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n\n      callback(null, doc);\n    });\n  });\n}\n/*!\n * ignore\n */\n\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n\n  ctx.once('cursor', function (cursor) {\n    if (cursor == null) {\n      return;\n    }\n\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;","map":{"version":3,"names":["Readable","require","promiseOrCallback","eachAsync","helpers","immediate","util","QueryCursor","query","options","call","autoDestroy","objectMode","cursor","_this","model","_mongooseOptions","_transforms","hooks","execPre","err","_markError","listeners","length","emit","concat","slice","transform","push","batchSize","_populateBatchSize","Math","min","collection","find","_conditions","_error","close","inherits","prototype","_read","_next","error","doc","Object","defineProperty","value","fn","enumerable","configurable","writable","callback","cb","events","next","opts","addCursorFlag","flag","_waitForCursor","transformNull","val","arguments","_transformForAsyncIterator","indexOf","map","Symbol","asyncIterator","done","ctx","reduce","populate","_pop","preparePopulationOptionsMQ","__noPromise","_batchDocs","_nextDoc","shift","_batchExhausted","_onNext","bind","once","removeListener","_populateBatch","pop","lean","execPost","_fields","_userProvidedFields","createModelAndInit","module","exports"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/cursor/QueryCursor.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst Readable = require('stream').Readable;\nconst promiseOrCallback = require('../helpers/promiseOrCallback');\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst helpers = require('../queryhelpers');\nconst immediate = require('../helpers/immediate');\nconst util = require('util');\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](/docs/api.html#query_Query-cursor) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query, options) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.query = query;\n  const _this = this;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = options || {};\n\n  model.hooks.execPre('find', query, (err) => {\n    if (err != null) {\n      _this._markError(err);\n      _this.listeners('error').length > 0 && _this.emit('error', err);\n      return;\n    }\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      this.options.cursor = options.cursor || {};\n      this.options.cursor.batchSize = options.batchSize;\n\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n    model.collection.find(query._conditions, this.options, (err, cursor) => {\n      if (err != null) {\n        _this._markError(err);\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n        return;\n      }\n\n      if (_this._error) {\n        cursor.close(function() {});\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n      }\n      _this.cursor = cursor;\n      _this.emit('cursor', cursor);\n    });\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * Necessary to satisfy the Readable API\n */\n\nQueryCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/*!\n * Marks this cursor as errored\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close https://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\nQueryCursor.prototype.close = function(callback) {\n  return promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n      this.emit('close');\n      cb(null);\n    });\n  }, this.model.events);\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = function(callback) {\n  return promiseOrCallback(callback, cb => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return cb(error);\n      }\n      cb(null, doc);\n    });\n  }, this.model.events);\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf Query\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        return ctx.cursor.next(_onNext.bind({ ctx, callback }));\n      }\n    } else {\n      return ctx.cursor.next(function(error, doc) {\n        if (error) {\n          return callback(error);\n        }\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        if (!ctx.query._mongooseOptions.populate) {\n          return _nextDoc(ctx, doc, null, callback);\n        }\n\n        ctx.query.model.populate(doc, ctx._pop, function(err, doc) {\n          if (err) {\n            return callback(err);\n          }\n          return _nextDoc(ctx, doc, ctx._pop, callback);\n        });\n      });\n    }\n  } else {\n    ctx.once('error', cb);\n\n    ctx.once('cursor', function(cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));\n    }\n    this.ctx.cursor.next(_onNext.bind(this));\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  const _this = this;\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {\n    if (err) {\n      return _this.callback(err);\n    }\n\n    _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  }\n\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function(cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}