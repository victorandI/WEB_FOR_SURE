{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = require('../error/validation');\n\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\n\nconst flatten = require('./common').flatten;\n\nconst modifiedPaths = require('./common').modifiedPaths;\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\n\nmodule.exports = function (query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);\n          }\n        }\n\n        continue;\n      }\n\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i]; // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n\n        if (key === '$set' || key === '$setOnInsert' || key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n  const alreadyValidated = [];\n  const context = query;\n\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n\n    if (schemaPath == null) {\n      return;\n    }\n\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(v, function (err) {\n            if (err) {\n              err.path = updates[i] + '.$in.' + i;\n              validationErrors.push(err);\n            }\n\n            callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] && schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(v, function (err) {\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n              return callback(null);\n            }\n\n            v.validate(function (err) {\n              if (err) {\n                if (err.errors) {\n                  for (const key of Object.keys(err.errors)) {\n                    const _err = err.errors[key];\n                    _err.path = updates[i] + '.' + key;\n                    validationErrors.push(_err);\n                  }\n                } else {\n                  err.path = updates[i];\n                  validationErrors.push(err);\n                }\n              }\n\n              callback(null);\n            });\n          }, context, {\n            updateValidator: true\n          });\n        });\n      } else {\n        validatorsToExecute.push(function (callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function (err) {\n            if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n\n            callback(null);\n          }, context, {\n            updateValidator: true\n          });\n        });\n      }\n    }\n  }\n\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function (callback) {\n        schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function (callback) {\n          schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === 'query' ? query : null, {\n            updateValidator: true\n          });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n\n    for (const validator of validatorsToExecute) {\n      validator(function () {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function (callback) {\n    let numValidators = validatorsToExecute.length;\n\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n\n    for (const validator of validatorsToExecute) {\n      validator(function () {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function (err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n\n      callback(null);\n    };\n  }\n};","map":{"version":3,"names":["ValidationError","require","cleanPositionalOperators","flatten","modifiedPaths","module","exports","query","schema","castedDoc","options","callback","keys","Object","updatedKeys","updatedValues","isPull","arrayAtomicUpdates","numKeys","length","hasDollarUpdate","modified","currentUpdate","key","i","startsWith","_keys","ii","$each","concat","flat","paths","numPaths","j","updatedPath","includes","undefined","updates","numUpdates","validatorsToExecute","validationErrors","alreadyValidated","context","iter","v","schemaPath","_getSchema","instance","path","Array","isArray","$in","forEach","push","doValidate","err","updateValidator","$isMongooseArray","$isMongooseDocumentArrayElement","$__","validate","errors","_err","storeSubdocValidationError","arrayUpdates","arrayUpdate","$isMongooseDocumentArray","getValidationCallback","atomicUpdate","numValidators","_done","validator","validationError","addError"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/updateValidators.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\nconst modifiedPaths = require('./common').modifiedPaths;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n              return callback(null);\n            }\n\n            v.validate(function(err) {\n              if (err) {\n                if (err.errors) {\n                  for (const key of Object.keys(err.errors)) {\n                    const _err = err.errors[key];\n                    _err.path = updates[i] + '.' + key;\n                    validationErrors.push(_err);\n                  }\n                } else {\n                  err.path = updates[i];\n                  validationErrors.push(err);\n                }\n              }\n              callback(null);\n            });\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}