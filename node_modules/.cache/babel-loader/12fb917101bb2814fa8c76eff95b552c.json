{"ast":null,"code":"'use strict';\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value; // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n\n    if (originalPipeline[0] != null && originalPipeline[0].$match && !originalPipeline[0].$match[filterKey]) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue; // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, {\n          $match: match\n        });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({\n        $match: match\n      });\n    }\n  }\n};","map":{"version":3,"names":["module","exports","prepareDiscriminatorPipeline","pipeline","schema","prefix","discriminatorMapping","isRoot","originalPipeline","filterKey","length","key","discriminatorValue","value","$match","$geoNear","query","$search","match","splice","unshift"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null && originalPipeline[0].$match && !originalPipeline[0].$match[filterKey]) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,4BAAT,CAAsCC,QAAtC,EAAgDC,MAAhD,EAAwDC,MAAxD,EAAgE;EAC/E,MAAMC,oBAAoB,GAAGF,MAAM,IAAIA,MAAM,CAACE,oBAA9C;EACAD,MAAM,GAAGA,MAAM,IAAI,EAAnB;;EAEA,IAAIC,oBAAoB,IAAI,CAACA,oBAAoB,CAACC,MAAlD,EAA0D;IACxD,MAAMC,gBAAgB,GAAGL,QAAzB;IACA,MAAMM,SAAS,GAAG,CAACJ,MAAM,CAACK,MAAP,GAAgB,CAAhB,GAAoBL,MAAM,GAAG,GAA7B,GAAmCA,MAApC,IAA8CC,oBAAoB,CAACK,GAArF;IACA,MAAMC,kBAAkB,GAAGN,oBAAoB,CAACO,KAAhD,CAHwD,CAKxD;IACA;IACA;;IACA,IAAIL,gBAAgB,CAAC,CAAD,CAAhB,IAAuB,IAAvB,IAA+BA,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,MAAnD,IAA6D,CAACN,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,MAApB,CAA2BL,SAA3B,CAAlE,EAAyG;MACvGD,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,MAApB,CAA2BL,SAA3B,IAAwCG,kBAAxC,CADuG,CAEvG;MACA;IACD,CAJD,MAIO,IAAIJ,gBAAgB,CAAC,CAAD,CAAhB,IAAuB,IAAvB,IAA+BA,gBAAgB,CAAC,CAAD,CAAhB,CAAoBO,QAAvD,EAAiE;MACtEP,gBAAgB,CAAC,CAAD,CAAhB,CAAoBO,QAApB,CAA6BC,KAA7B,GACIR,gBAAgB,CAAC,CAAD,CAAhB,CAAoBO,QAApB,CAA6BC,KAA7B,IAAsC,EAD1C;MAEAR,gBAAgB,CAAC,CAAD,CAAhB,CAAoBO,QAApB,CAA6BC,KAA7B,CAAmCP,SAAnC,IAAgDG,kBAAhD;IACD,CAJM,MAIA,IAAIJ,gBAAgB,CAAC,CAAD,CAAhB,IAAuB,IAAvB,IAA+BA,gBAAgB,CAAC,CAAD,CAAhB,CAAoBS,OAAvD,EAAgE;MACrE,IAAIT,gBAAgB,CAAC,CAAD,CAAhB,IAAuBA,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,MAApB,IAA8B,IAAzD,EAA+D;QAC7DN,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,MAApB,CAA2BL,SAA3B,IAAwCD,gBAAgB,CAAC,CAAD,CAAhB,CAAoBM,MAApB,CAA2BL,SAA3B,KAAyCG,kBAAjF;MACD,CAFD,MAEO;QACL,MAAMM,KAAK,GAAG,EAAd;QACAA,KAAK,CAACT,SAAD,CAAL,GAAmBG,kBAAnB;QACAJ,gBAAgB,CAACW,MAAjB,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B;UAAEL,MAAM,EAAEI;QAAV,CAA9B;MACD;IACF,CARM,MAQA;MACL,MAAMA,KAAK,GAAG,EAAd;MACAA,KAAK,CAACT,SAAD,CAAL,GAAmBG,kBAAnB;MACAJ,gBAAgB,CAACY,OAAjB,CAAyB;QAAEN,MAAM,EAAEI;MAAV,CAAzB;IACD;EACF;AACF,CAlCD"},"metadata":{},"sourceType":"script"}