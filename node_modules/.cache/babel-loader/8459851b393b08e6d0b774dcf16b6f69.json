{"ast":null,"code":"'use strict';\n\nconst modifiedPaths = require('./common').modifiedPaths;\n\nconst get = require('./get');\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\n\nmodule.exports = function (filter, schema, castedDoc, options) {\n  options = options || {};\n  const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  const modified = {};\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].startsWith('$')) {\n          hasDollarKey = true;\n          break;\n        }\n      }\n\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n\n    updatedKeys[path] = true;\n    modified[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function (path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n\n    const def = schemaType.getDefault(null, true);\n\n    if (isModified(modified, path)) {\n      return;\n    }\n\n    if (typeof def === 'undefined') {\n      return;\n    }\n\n    if (schemaType.splitPath().includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n\n    updatedValues[path] = def;\n  });\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n\n  const sp = path.split('.');\n  let cur = sp[0];\n\n  for (let i = 1; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n\n    cur += '.' + sp[i];\n  }\n\n  return false;\n}","map":{"version":3,"names":["modifiedPaths","require","get","module","exports","filter","schema","castedDoc","options","shouldSetDefaultsOnInsert","setDefaultsOnInsert","base","upsert","keys","Object","updatedKeys","updatedValues","numKeys","length","modified","hasDollarUpdate","i","startsWith","paths","numPaths","path","condition","conditionKeys","numConditionKeys","hasDollarKey","j","overwrite","eachPath","schemaType","auto","def","getDefault","isModified","splitPath","includes","$setOnInsert","sp","split","cur"],"sources":["B:/web_project_react/web_car_react/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"],"sourcesContent":["'use strict';\nconst modifiedPaths = require('./common').modifiedPaths;\nconst get = require('./get');\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert =\n    options.setDefaultsOnInsert != null ?\n      options.setDefaultsOnInsert :\n      schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  const modified = {};\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].startsWith('$')) {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    modified[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (isModified(modified, path)) {\n      return;\n    }\n    if (typeof def === 'undefined') {\n      return;\n    }\n    if (schemaType.splitPath().includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n  const sp = path.split('.');\n  let cur = sp[0];\n  for (let i = 1; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n    cur += '.' + sp[i];\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}